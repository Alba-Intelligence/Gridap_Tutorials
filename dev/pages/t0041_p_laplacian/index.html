<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4 p-Laplacian · Gridap tutorials</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gridap tutorials</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Introduction</a></li><li><a class="toctext" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="toctext" href="../t002_validation/">2 Code validation</a></li><li><a class="toctext" href="../t003_elasticity/">3 Linear elasticity</a></li><li class="current"><a class="toctext" href>4 p-Laplacian</a><ul class="internal"><li><a class="toctext" href="#Learning-outcomes-1">Learning outcomes</a></li><li><a class="toctext" href="#Problem-statement-1">Problem statement</a></li><li><a class="toctext" href="#Numerical-scheme-1">Numerical scheme</a></li><li><a class="toctext" href="#Implementation-1">Implementation</a></li></ul></li><li><a class="toctext" href="../t004_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="toctext" href="../t005_dg_discretization/">6 Poisson equation (with DG)</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>4 p-Laplacian</a></li></ul><a class="edit-page" href="https://github.com/gridap/Tutorials/blob/master/src/t0041_p_laplacian.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>4 p-Laplacian</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-4:-p-Laplacian-1" href="#Tutorial-4:-p-Laplacian-1">Tutorial 4: p-Laplacian</a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t0041_p_laplacian.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t0041_p_laplacian.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><h2><a class="nav-anchor" id="Learning-outcomes-1" href="#Learning-outcomes-1">Learning outcomes</a></h2><ul><li>How to solve a simple non-linear PDE in Gridap</li><li>How to define the weak residual and its Jacobian</li><li>How to setup and use a non-linear solver</li><li>How to define new boundaries from a given discrete model</li><li>How to interpolate a function in a FE space</li></ul><h2><a class="nav-anchor" id="Problem-statement-1" href="#Problem-statement-1">Problem statement</a></h2><p>The goal of this tutorial is to solve a non-linear PDE in Gridap. For the sake of simplicity, we consider the <a href="https://en.wikipedia.org/wiki/P-Laplacian">p-Laplacian</a> as the model problem. More complex PDEs will be considered in other tutorials. See, e.g., the tutorial on geometrically non-linear elasticity (hyper-elasticity) or the one on the incompressible Navier-Stokes equation. Here, the PDE we want to solve is</p><div>\[\left\lbrace
\begin{aligned}
-\nabla \cdot \left( |\nabla u|^{p-2} \ \nabla u \right) = f\ \text{in}\ \Omega\\
u = 0 \ \text{on} \ \Gamma_0\\
u = g \ \text{on} \ \Gamma_g\\
\left( |\nabla u|^{p-2}\ \nabla u \right)\cdot n = 0 \ \text{on} \ \Gamma_{\rm N}
\end{aligned}
\right.\]</div><p>which is the p-Laplacian equation of degree <span>$p&gt;2$</span>, equipped with homogeneous Dirichlet and Neumann boundary conditions on <span>$\Gamma_0$</span> and <span>$\Gamma_{\rm N}$</span>  respectively, and in-homogeneous Dirichlet conditions on <span>$\Gamma_g$</span>.  The domain <span>$\Omega$</span> is the one depicted in the figure below. The Dirichlet boundaries <span>$\Gamma_0$</span> and <span>$\Gamma_g$</span> are defined as the closure of the green and blue surfaces respectively, whereas the Neumann boundary is the remaining portion of the boundary <span>$\Gamma_{\rm N}\doteq\partial\Omega \setminus (\Gamma_0\cup\Gamma_g)$</span>. In this example, we consider the values <span>$p=3$</span>, <span>$f=1$</span>, and <span>$g=2$</span>.</p><p><img src="../../assets/t0041_p_laplacian/model.png" alt/></p><h2><a class="nav-anchor" id="Numerical-scheme-1" href="#Numerical-scheme-1">Numerical scheme</a></h2><p>As in previous tutorials, we discretize the problem with conforming Lagrangian FE spaces. For this formulation, the weak form reads: find <span>$u\in U_g$</span> such that <span>$[r(u)](v) = 0$</span> for all <span>$v\in V_0$</span>, where the weak residual <span>$r: U_g \rightarrow (V_0)^\prime$</span> is defined as</p><div>\[[r(u)](v) \doteq \int_\Omega \nabla v \cdot \left( |\nabla u|^{p-2}\ \nabla u \right) \ {\rm d}\Omega - \int_\Omega v\ f \ {\rm d}\Omega.\]</div><p>The space <span>$U_g$</span> is the set of functions in <span>$H^1(\Omega)$</span> that fulfill the Dirichlet boundary conditions, whereas <span>$V_0$</span> is composed by functions in <span>$H^1(\Omega)$</span> that vanish at the Dirichlet boundary.</p><p>In order to solve this non-linear weak equation, we consider a Newton-Raphson method, which is associated with the following linearization of the problem:  <span>$[r(u+\delta u)](v)\approx [r(u)](v) + [j(u)](v,\delta u)$</span>. In previous formula, <span>$j(u)$</span> is the Jacobian evaluated at <span>$u\in U_g$</span>, which is the bilinear form defined as</p><div>\[[j(u)](v,\delta u) \doteq \left.\dfrac{\rm d}{{\rm d} \varepsilon}\right|_{\varepsilon = 0} [r(u+\varepsilon \ \delta u)](v).\]</div><p>For the current example, we have</p><div>\[[j(u)](v,\delta u) = \int_\Omega \nabla v \cdot \left( |\nabla u|^{p-2}\ \nabla \delta u \right) \ {\rm d}\Omega + (p-2) \int_\Omega \nabla v \cdot \left(  |\nabla u|^{p-4} (\nabla u \cdot \nabla \delta u) \nabla u  \right) \ {\rm d}\Omega.\]</div><p>Note that the solution of this non-linear PDE with the Newton-Raphson method, will require to discretize both the residual <span>$r$</span> and the Jacobian <span>$j$</span>. In Gridap, this is done by following an approach similar to the one already shown in previous tutorials for discretizing the bilinear and linear forms associated with linear FE problems. The specific details are discussed in next section.</p><h2><a class="nav-anchor" id="Implementation-1" href="#Implementation-1">Implementation</a></h2><h3><a class="nav-anchor" id="Discrete-model-1" href="#Discrete-model-1">Discrete model</a></h3><p>As in previous tutorials, the first step to solve the PDE at hand is to load the discretization of the computational domain. In this case, we load the model from a file</p><pre><code class="language-julia">using Gridap

model = DiscreteModelFromFile(&quot;../models/model.json&quot;);</code></pre><p>Once we have build the discrete model, we can inspect it in order to see which boundaries are defined in it. To this end, write the model to vtk format and open the resulting file in paraview.</p><pre><code class="language-julia">writevtk(model,&quot;model&quot;);</code></pre><p>As stated before, we need to impose Dirichlet boundary conditions on <span>$\Gamma_0$</span> and <span>$\Gamma_g$</span>,  but none of these boundaries is identified in the model. E.g., you can easily see by opening the file <code>model_0</code> in paraview that the boundary identified as <code>&quot;sides&quot;</code> only includes the vertices in the interior of <span>$\Gamma_0$</span>, but we want to impose Dirichlet boundary conditions also on the vertices on the contour of <span>$\Gamma_0$</span>. Fortunately, the objects on the contour of <span>$\Gamma_0$</span> are identified  with the tag <code>&quot;sides_c&quot;</code> (see figure below). Thus, the Dirichlet boundary <span>$\Gamma_0$</span> can be build as the union of the objects identified as <code>&quot;sides&quot;</code> and <code>&quot;sides_c&quot;</code>.</p><p><img src="../../assets/t0041_p_laplacian/sides_c.png" alt/></p><p>Gridap provides a convenient way to create new object identifiers (referred as &quot;tags&quot;) from existing ones. It is done as follows. First, we need to extract from the model, the object that holds the information about the boundary identifiers, which in Gridap is represented with the <code>FaceLabels</code> type:</p><pre><code class="language-julia">labels = FaceLabels(model);</code></pre><p>Once we have the <code>FaceLabels</code> object (in this case stored in the variable <code>labels</code>), we can add new identifiers (aka &quot;tags&quot;) to it. In the next line we create a new tag called <code>&quot;diri0&quot;</code> as the union of the objects identified as <code>&quot;sides&quot;</code> and <code>&quot;sides_c&quot;</code>, which is precisely what we need to represent the Dirichlet boundary <span>$\Gamma_0$</span>.</p><pre><code class="language-julia">add_tag_from_tags!(labels,&quot;diri0&quot;,[&quot;sides&quot;, &quot;sides_c&quot;]);</code></pre><p>We follow the same approach to build a new identifier for the Dirichlet boundary <span>$\Gamma_g$</span>. In this case, objects in <span>$\Gamma_g$</span> can be expressed as the union of the objects identified with the tags <code>&quot;circle&quot;</code>, <code>&quot;circle_c&quot;</code>, <code>&quot;triangle&quot;</code>, <code>&quot;triangle_c&quot;</code>, <code>&quot;square&quot;</code>, <code>&quot;square_c&quot;</code>. Thus, we create a new tag for  <span>$\Gamma_g$</span>, called <code>&quot;dirig&quot;</code> simply as follows:</p><pre><code class="language-julia">add_tag_from_tags!(labels,&quot;dirig&quot;,
  [&quot;circle&quot;,&quot;circle_c&quot;, &quot;triangle&quot;, &quot;triangle_c&quot;, &quot;square&quot;, &quot;square_c&quot;])</code></pre><h3><a class="nav-anchor" id="FE-Spaces-1" href="#FE-Spaces-1">FE Spaces</a></h3><p>Now, we can build the FE spaces by using the newly defined boundary tags.</p><pre><code class="language-julia">order = 1
diritags = [&quot;diri0&quot;, &quot;dirig&quot;]
V = CLagrangianFESpace(Float64,model,labels,order,diritags);</code></pre><p>Note that, we pass the <code>labels</code> variable (that contains the newly created boundary tags) in the third argument of the <code>CLagrangianFESpace</code> constructor.</p><p>From this FE space, we can define the test and trial FE spaces as always</p><pre><code class="language-julia">g = 1.0
V0 = TestFESpace(V)
Ug = TrialFESpace(V,[0.0,g]);</code></pre><p>We have set a value of <code>0.0</code> on the boundary <code>&quot;diri0&quot;</code> and a value of <code>g=1.0</code> on the boundary <code>&quot;dirig&quot;</code>, when constructing the trial FE space (in accordance to the problem statement). Note also that we are passing values instead of functions in order describe the prescribed Dirichlet data. This is possible since the Dirichlet conditions are described with constant functions in this example.</p><p>We can perform a final check to see if we have properly imposed the Dirichlet boundary conditions. If we interpolate a constant function, namely <span>$w(x) = -1$</span>, in the trial FE space <span>$U_g$</span>, the resulting function <span>$w_h$</span> has to be equal to -1 in the nodes that are not on the Dirichlet boundary. On the other hand, function <span>$w_h$</span> has to fulfill the boundary conditions at the nodes on the Dirichlet boundary. That is <span>$w_h$</span> has to be <span>$0$</span> on <span>$\Gamma_0$</span>, <span>$1$</span> on <span>$\Gamma_g$</span>.</p><p>We can easily check that this is indeed so in the code. The interpolation is done with the <code>interpolate</code> function:</p><pre><code class="language-julia">w(x) = -1.0
wh = interpolate(Ug,w)</code></pre><p>The computed object <code>wh</code> is an instance of <code>FEFunction</code> and it represents the interpolated function. We can visualize it as we have already done in previous tutorials with the numerical solution of the problem:</p><pre><code class="language-julia">trian = Triangulation(model)
writevtk(trian,&quot;wh&quot;,cellfields=[&quot;wh&quot;=&gt;wh])</code></pre><p>If you open the generated file <code>wh.vtu</code> with paraview and chose to color the solid by the field <code>&quot;wh&quot;</code> you can confirm that the interpolated function fulfills the Dirichlet boundary conditions as expected (see figure below).</p><p><img src="../../assets/t0041_p_laplacian/wh.png" alt/></p><h3><a class="nav-anchor" id="Non-linear-FE-problem-1" href="#Non-linear-FE-problem-1">Non-linear FE problem</a></h3><p>At this point, we are ready to build the non-linear FE problem. To this end, we need to define the weak residual and also its corresponding Jacobian. This is done following a similar procedure to the one considered in previous tutorials to define the bilinear and linear forms associated with linear FE problems. In this case, instead of an <code>AffineFETerm</code> (which is for linear problems), we use a <code>NonLinearFETerm</code>. An instance of <code>NonLinearFETerm</code> is constructed by providing the integrands of the weak residual and the Jacobian (in a similar way an <code>AffineFETerm</code> is constructed from the integrands of the bilinear and linear forms). The integrand of the weak residual is build as follows</p><pre><code class="language-julia">using LinearAlgebra: norm
const p = 3
@law flux(x,∇u) = norm(∇u)^(p-2) * ∇u
f(x) = 1.0
res(u,v) = inner( ∇(v), flux(∇(u)) ) - inner(v,f)</code></pre><p>Function <code>res</code> is the one representing the integrand of the weak residual <span>$[r(u)](v)$</span>. The first argument of function <code>res</code> represents the function <span>$u\in U_g$</span>, where the residual is evaluated. The second argument represents a generic test function <span>$v\in V_0$</span>. Note that we have used the macro <code>@law</code> to construct a constitutive relation (in that case the non-linear flux associated with the gradient of the solution).</p><p>On the other hand,  the integrand of the Jacobian is computed as</p><pre><code class="language-julia">@law dflux(x,∇du,∇u) = (p-2)*norm(∇u)^(p-4)*inner(∇u,∇du)*∇u + norm(∇u)^(p-2) * ∇du
jac(u,v,du) = inner(  ∇(v) , dflux(∇(du),∇(u)) )</code></pre><p>Function <code>jac</code> represents the integrand of the Jacobian <span>$[j(u)](v,\delta u)$</span>. The first argument of function <code>jac</code> stands for function <span>$u\in U_g$</span> where the Jacobian is evaluated. The second argument is a test function <span>$v\in V_0$</span>. The third argument represents an infinitesimal solution increment <span>$\delta u \in V_0$</span>. Note that we have also used the macro <code>@law</code> to define the &quot;linearization&quot; of the non-linear flux.</p><p>With these functions, we build the <code>NonLinearFETerm</code> as follows:</p><pre><code class="language-julia">quad = CellQuadrature(trian,degree=2)
t_Ω = NonLinearFETerm(res,jac,trian,quad)</code></pre><p>Note that we pass in the first and second arguments the functions that represent the integrands of the residual and Jacobian respectively. The other two arguments, are the triangulation and quadrature used to perform the integrals numerically on the corresponding domain (in this case the volume <span>$\Omega$</span>).</p><p>From this <code>NonLinearFETerm</code> object, we finally construct the non-linear FE problem:</p><pre><code class="language-julia">op = NonLinearFEOperator(V,Ug,t_Ω)</code></pre><p>In previous line, we have constructed an instance of <code>NonLinearFEOperator</code>, which is the type that represents a general non-linear FE problem in Gridap. The constructor takes the test and trial spaces of the problem, and the <code>FETerms</code> objects describing the corresponding weak form (in this case only a single term).</p><h3><a class="nav-anchor" id="Non-linear-solver-phase-1" href="#Non-linear-solver-phase-1">Non-linear solver phase</a></h3><p>We have already built the non-linear FE problem. Now, the remaining step is to solve it. In Gridap, non-linear (and also linear) FE problems can be solved with instances of the type <code>NonLinearFESolver</code>. The type <code>NonLinearFESolver</code> is a concrete implementation of the abstract type <code>FESolver</code> particularly designed for non-linear problems (in contrast to the concrete type <code>LinearFESolver</code> which is for the linear case).</p><p>A <code>NonLinearFESolver</code> is constructed from an algebraic non-linear solver (e.g., a Newton-Raphson method, a trust-region solver, etc.). In Gridap non-linear algebraic solvers are represented by types inheriting from the abstract type <code>NonLinearSolver</code>. In this tutorial, we consider a concrete implementation of <code>NonLinearSolver</code> called <code>NLSolver</code>, which uses the <code>nlsove</code> function of the official Julia package <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve</a> to solve the underlying non-linear algebraic problem.</p><p>We construct an instance of <code>NLSolver</code> as follows:</p><pre><code class="language-julia">using LineSearches: BackTracking

ls = BackslashSolver()
nls = NLSolver(
  ls; show_trace=true, method=:newton, linesearch=BackTracking())</code></pre><p>The <code>NLSolver</code> constructor takes a single positional argument and several keyword arguments. In the positional argument, we pass the linear solver we want to use at each non-linear iteration (which will be used only if the chosen non-linear solution method requires to solve linear systems of algebraic equations at each iterations). In this case, we use a <code>BackslashSolver</code> which is a wrapper of the Julia built-in &quot;backslash&quot; operator. On the other hand, the valid key word arguments of the <code>NLSolver</code> constructor are the same as the ones of function <code>nlsolve</code> of the <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve</a> package (see the documentation of this package for more information). In this example, we are selecting a Newton-Raphson method with a back-traking line-search.</p><p>Now, we are in place to build the <code>NonLinearFESolver</code> object:</p><pre><code class="language-julia">solver = NonLinearFESolver(nls)</code></pre><p>To finally solve the non-linear FE problem, we need to chose an initial guess. The initial guess is a <code>FEFunction</code>, which we build from a vector of random  (free) nodal values:</p><pre><code class="language-julia">import Random
Random.seed!(1234)

x = rand(Float64,num_free_dofs(Ug))
uh = FEFunction(Ug,x)</code></pre><p>Using the initial guess and the non-linear FE solver, we solve the problem as follows:</p><pre><code class="language-julia">solve!(uh,solver,op)</code></pre><p>If you run previous line in a jupyter notebook, you will see a trace of the non-linear iterations like this one:</p><pre><code class="language-none">Iter     f(x) inf-norm    Step 2-norm
------   --------------   --------------
     0     1.139082e+01              NaN
     1     2.849303e+00     2.361896e+02
     2     7.176996e-01     6.262418e+01
     3     1.917792e-01     1.761268e+01
     4     5.525576e-02     4.295340e+00
     5     1.186876e-02     6.847898e-01
     6     2.359521e-03     7.063845e-02
     7     3.170074e-04     5.936403e-03
     8     6.754149e-05     5.142141e-04
     9     1.195143e-05     4.066167e-05
    10     2.308345e-06     1.832637e-06
    11     8.679377e-08     2.492892e-08
    12     1.375616e-10     3.492308e-11</code></pre><p>Note that the <code>solve!</code> function updates the given initial guess with the solution of the problem.  That is, once function <code>solve!</code> finishes, the variable <code>uh</code> contains the solution of the problem. To visualize it, execute following line and inspect the generated file with paraview.</p><pre><code class="language-julia">writevtk(trian,&quot;results&quot;,cellfields=[&quot;uh&quot;=&gt;uh])</code></pre><p><img src="../../assets/t0041_p_laplacian/sol-plap.png" alt/></p><p>Congratulations, another tutorial done!</p><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../t003_elasticity/"><span class="direction">Previous</span><span class="title">3 Linear elasticity</span></a><a class="next" href="../t004_hyperelasticity/"><span class="direction">Next</span><span class="title">5 Hyper-elasticity</span></a></footer></article></body></html>
