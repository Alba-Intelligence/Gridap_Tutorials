<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4 p-Laplacian · Gridap tutorials</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gridap tutorials</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Introduction</a></li><li><a class="toctext" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="toctext" href="../t002_validation/">2 Code validation</a></li><li><a class="toctext" href="../t003_elasticity/">3 Linear elasticity</a></li><li class="current"><a class="toctext" href>4 p-Laplacian</a><ul class="internal"><li><a class="toctext" href="#Problem-statement-1">Problem statement</a></li><li><a class="toctext" href="#Numerical-scheme-1">Numerical scheme</a></li><li><a class="toctext" href="#Discrete-model-1">Discrete model</a></li><li><a class="toctext" href="#FE-Space-1">FE Space</a></li><li><a class="toctext" href="#Nonlinear-FE-problem-1">Nonlinear FE problem</a></li><li><a class="toctext" href="#Nonlinear-solver-phase-1">Nonlinear solver phase</a></li></ul></li><li><a class="toctext" href="../t004_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="toctext" href="../t005_dg_discretization/">6 Poisson equation (with DG)</a></li><li><a class="toctext" href="../t007_darcy/">7 Darcy equation (with RT)</a></li><li><a class="toctext" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>4 p-Laplacian</a></li></ul><a class="edit-page" href="https://github.com/gridap/Tutorials/blob/master/src/t0041_p_laplacian.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>4 p-Laplacian</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-4:-p-Laplacian-1" href="#Tutorial-4:-p-Laplacian-1">Tutorial 4: p-Laplacian</a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t0041_p_laplacian.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t0041_p_laplacian.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will learn</p><ul><li>How to solve a simple nonlinear PDE in Gridap</li><li>How to define the weak residual and its Jacobian</li><li>How to setup and use a nonlinear solver</li><li>How to define new boundaries from a given discrete model</li></ul><h2><a class="nav-anchor" id="Problem-statement-1" href="#Problem-statement-1">Problem statement</a></h2><p>The goal of this tutorial is to solve a nonlinear PDE in Gridap. For the sake of simplicity, we consider the <span>$p$</span>-Laplacian equation as the model problem. Specifically, the PDE  we want to solve is: find the scalar-field <span>$u$</span> such that</p><div>\[\left\lbrace
\begin{aligned}
-\nabla \cdot \left( |\nabla u|^{p-2} \ \nabla u \right) = f\ &amp;\text{in}\ \Omega,\\
u = 0 \ &amp;\text{on} \ \Gamma_0,\\
u = g \ &amp;\text{on} \ \Gamma_g,\\
\left( |\nabla u|^{p-2}\ \nabla u \right)\cdot n = 0 \ &amp;\text{on} \ \Gamma_{\rm N},
\end{aligned}
\right.\]</div><p>with <span>$p&gt;2$</span>. The computational domain <span>$\Omega$</span> is the one depicted in next figure, which is the same as in the first tutorial. However, we slightly change the boundary conditions here. We impose homogeneous Dirichlet and homogeneous Neumann boundary conditions on <span>$\Gamma_0$</span> and <span>$\Gamma_{\rm N}$</span>  respectively, and in-homogeneous Dirichlet conditions on <span>$\Gamma_g$</span>. The Dirichlet boundaries <span>$\Gamma_0$</span> and <span>$\Gamma_g$</span> are defined as the closure of the green and blue surfaces in next figure respectively, whereas the Neumann boundary is <span>$\Gamma_{\rm N}\doteq\partial\Omega \setminus (\Gamma_0\cup\Gamma_g)$</span>. In this example, we consider the values <span>$p=3$</span>, <span>$f=1$</span>, and <span>$g=2$</span>.</p><p><img src="../../assets/t0041_p_laplacian/model.png" alt/></p><h2><a class="nav-anchor" id="Numerical-scheme-1" href="#Numerical-scheme-1">Numerical scheme</a></h2><p>We discretize the problem with conforming Lagrangian FE spaces. For this formulation, the nonlinear weak form reads: find <span>$u\in U_g$</span> such that <span>$[r(u)](v) = 0$</span> for all <span>$v\in V_0$</span>. As in previous tutorials, the space <span>$U_g$</span> is the set of functions in <span>$H^1(\Omega)$</span> that fulfill the Dirichlet boundary conditions, whereas <span>$V_0$</span> is composed by functions in <span>$H^1(\Omega)$</span> that vanish at the Dirichlet boundary. The weak residual <span>$r(u)$</span> evaluated at a function  <span>$u\in U_g$</span> is the linear form defined as</p><div>\[[r(u)](v) \doteq \int_\Omega \nabla v \cdot \left( |\nabla u|^{p-2}\ \nabla u \right) \ {\rm d}\Omega - \int_\Omega v\ f \ {\rm d}\Omega.\]</div><p>In order to solve this nonlinear weak equation, we consider a Newton-Raphson method, which is associated with a linearization of the problem in an arbitrary direction <span>$\delta u\in V_0$</span>, namely <span>$[r(u+\delta u)](v)\approx [r(u)](v) + [j(u)](v,\delta u)$</span>. In previous formula,  <span>$j(u)$</span> is the Jacobian evaluated at <span>$u\in U_g$</span>, which is the bilinear form</p><div>\[[j(u)](v,\delta u) = \int_\Omega \nabla v \cdot \left( |\nabla u|^{p-2}\ \nabla \delta u \right) \ {\rm d}\Omega + (p-2) \int_\Omega \nabla v \cdot \left(  |\nabla u|^{p-4} (\nabla u \cdot \nabla \delta u) \nabla u  \right) \ {\rm d}\Omega.\]</div><p>Note that the solution of this nonlinear PDE with a Newton-Raphson method, will require to discretize both the residual <span>$r$</span> and the Jacobian <span>$j$</span>. In Gridap, this is done by following an approach similar to the one already shown in previous tutorials for discretizing the bilinear and linear forms associated with a linear FE problem. The specific details are discussed now.</p><h2><a class="nav-anchor" id="Discrete-model-1" href="#Discrete-model-1">Discrete model</a></h2><p>As in previous tutorials, the first step to solve the PDE is to load a discretization of the computational domain. In this case, we load the model from the same file as in the first tutorial</p><pre><code class="language-julia">using Gridap
model = DiscreteModelFromFile(&quot;../models/model.json&quot;)</code></pre><p>As stated before, we want to impose Dirichlet boundary conditions on <span>$\Gamma_0$</span> and <span>$\Gamma_g$</span>,  but none of these boundaries is identified in the model. E.g., you can easily see by writing the model in vtk format</p><pre><code class="language-julia">writevtk(model,&quot;model&quot;)</code></pre><p>and by opening the file <code>&quot;model_0&quot;</code> in Paraview that the boundary identified as <code>&quot;sides&quot;</code> only includes the vertices in the interior of <span>$\Gamma_0$</span>, but here we want to impose Dirichlet boundary conditions in the closure of <span>$\Gamma_0$</span>, i.e., also on the vertices on the contour of <span>$\Gamma_0$</span>. Fortunately, the objects on the contour of <span>$\Gamma_0$</span> are identified  with the tag <code>&quot;sides_c&quot;</code> (see next figure). Thus, the Dirichlet boundary <span>$\Gamma_0$</span> can be build as the union of the objects identified as <code>&quot;sides&quot;</code> and <code>&quot;sides_c&quot;</code>.</p><p><img src="../../assets/t0041_p_laplacian/sides_c.png" alt/></p><p>Gridap provides a convenient way to create new object identifiers (referred to as &quot;tags&quot;) from existing ones. First, we need to extract from the model, the object that holds the information about the boundary identifiers (referred to as <code>FaceLabels</code>):</p><pre><code class="language-julia">labels = FaceLabels(model)</code></pre><p>Then, we can add new identifiers (aka &quot;tags&quot;) to it. In the next line, we create a new tag called <code>&quot;diri0&quot;</code> as the union of the objects identified as <code>&quot;sides&quot;</code> and <code>&quot;sides_c&quot;</code>, which is precisely what we need to represent the closure of the Dirichlet boundary <span>$\Gamma_0$</span>.</p><pre><code class="language-julia">add_tag_from_tags!(labels,&quot;diri0&quot;,[&quot;sides&quot;, &quot;sides_c&quot;])</code></pre><p>We follow the same approach to build a new identifier for the closure of the Dirichlet boundary <span>$\Gamma_g$</span>. In this case, the boundary is expressed as the union of the objects identified with the tags <code>&quot;circle&quot;</code>, <code>&quot;circle_c&quot;</code>, <code>&quot;triangle&quot;</code>, <code>&quot;triangle_c&quot;</code>, <code>&quot;square&quot;</code>, <code>&quot;square_c&quot;</code>. Thus, we create a new tag for  <span>$\Gamma_g$</span>, called <code>&quot;dirig&quot;</code> simply as follows:</p><pre><code class="language-julia">add_tag_from_tags!(labels,&quot;dirig&quot;,
  [&quot;circle&quot;,&quot;circle_c&quot;, &quot;triangle&quot;, &quot;triangle_c&quot;, &quot;square&quot;, &quot;square_c&quot;])</code></pre><h2><a class="nav-anchor" id="FE-Space-1" href="#FE-Space-1">FE Space</a></h2><p>Now, we can build the FE space by using the newly defined boundary tags.</p><pre><code class="language-julia">V = FESpace(
  reffe=:Lagrangian, order=1, valuetype=Float64,
  conformity=:H1, model=model, labels=labels,
  diritags=[&quot;diri0&quot;, &quot;dirig&quot;])</code></pre><p>The construction of this space is essentially the same as in the first tutorial (we build a continuous scalar-valued Lagrangian interpolation of first order). However, we also pass here the <code>labels</code> object (that contains the newly created boundary tags). From this FE space, we define the test and trial FE spaces</p><pre><code class="language-julia">g = 1.0
V0 = TestFESpace(V)
Ug = TrialFESpace(V,[0.0,g])</code></pre><h2><a class="nav-anchor" id="Nonlinear-FE-problem-1" href="#Nonlinear-FE-problem-1">Nonlinear FE problem</a></h2><p>At this point, we are ready to build the nonlinear FE problem. To this end, we need to define the weak residual and also its corresponding Jacobian. This is done following a similar procedure to the one considered in previous tutorials to define the bilinear and linear forms associated with linear FE problems. In this case, instead of an <code>AffineFETerm</code> (which is for linear problems), we use a <code>NonLinearFETerm</code>. An instance of <code>NonLinearFETerm</code> is constructed by providing the integrands of the weak residual and its Jacobian (in a similar way an <code>AffineFETerm</code> is constructed from the integrands of the bilinear and linear forms).</p><p>On the one hand, the integrand of the weak residual is build as follows</p><pre><code class="language-julia">using LinearAlgebra: norm
const p = 3
@law flux(x,∇u) = norm(∇u)^(p-2) * ∇u
f(x) = 1.0
res(u,v) = inner( ∇(v), flux(∇(u)) ) - inner(v,f)</code></pre><p>Function <code>res</code> is the one representing the integrand of the weak residual <span>$[r(u)](v)$</span>. The first argument of function <code>res</code> stands for the function <span>$u\in U_g$</span>, where the residual is evaluated, and the second argument stands for a generic test function <span>$v\in V_0$</span>. Note that we have used the macro <code>@law</code> to construct the &quot;constitutive  law&quot; that relates the nonlinear flux with the gradient of the solution.</p><p>On the other hand,  we implement a function <code>jac</code> representing the integrand of the Jacobian</p><pre><code class="language-julia">@law dflux(x,∇du,∇u) =
  (p-2)*norm(∇u)^(p-4)*inner(∇u,∇du)*∇u + norm(∇u)^(p-2) * ∇du
jac(u,v,du) = inner(  ∇(v) , dflux(∇(du),∇(u)) )</code></pre><p>The first argument of function <code>jac</code> stands for function <span>$u\in U_g$</span>, where the Jacobian is evaluated. The second argument is a test function <span>$v\in V_0$</span>, and the third argument represents an arbitrary direction <span>$\delta u \in V_0$</span>. Note that we have also used the macro <code>@law</code> to define the linearization of the nonlinear flux.</p><p>With these functions, we build the <code>NonLinearFETerm</code> as follows:</p><pre><code class="language-julia">trian = Triangulation(model)
quad = CellQuadrature(trian,degree=2)
t_Ω = NonLinearFETerm(res,jac,trian,quad)</code></pre><p>We build the <code>NonLinearFETerm</code> by passing in the first and second arguments the functions that represent the integrands of the residual and Jacobian respectively. The other two arguments, are the triangulation and quadrature used to perform the integrals numerically. From this <code>NonLinearFETerm</code> object, we finally construct the nonlinear FE problem</p><pre><code class="language-julia">op = NonLinearFEOperator(V,Ug,t_Ω)</code></pre><p>Here, we have constructed an instance of <code>NonLinearFEOperator</code>, which is the type that represents a general nonlinear FE problem in Gridap. The constructor takes the test and trial spaces, and the <code>FETerms</code> objects describing the corresponding weak form (in this case only a single term).</p><h2><a class="nav-anchor" id="Nonlinear-solver-phase-1" href="#Nonlinear-solver-phase-1">Nonlinear solver phase</a></h2><p>We have already built the nonlinear FE problem. Now, the remaining step is to solve it. In Gridap, nonlinear (and also linear) FE problems can be solved with instances of the type <code>NonLinearFESolver</code>. The type <code>NonLinearFESolver</code> is a concrete implementation of the abstract type <code>FESolver</code> particularly designed for nonlinear problems (in contrast to the concrete type <code>LinearFESolver</code> which is for the linear case).</p><p>We construct an instance of <code>NonLinearFESolver</code> as follows:</p><pre><code class="language-julia">using LineSearches: BackTracking
nls = NLSolver(
  show_trace=true, method=:newton, linesearch=BackTracking())
solver = NonLinearFESolver(nls)</code></pre><p>Note that the <code>NLSolver</code> function used above internally calls the <code>nlsolve</code> function of the <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve</a> package with the provided key-word arguments. Thus, one can use any of the nonlinear methods available via the function <code>nlsolve</code> to solve the nonlinear FE problem. Here, we have selected a Newton-Raphson method with a back-tracking line-search from the <a href="https://github.com/JuliaNLSolvers/LineSearches.jl">LineSearches</a> package.</p><p>We are finally in place to solve the nonlinear FE problem. The initial guess is a <code>FEFunction</code>, which we build from a vector of random (free) nodal values:</p><pre><code class="language-julia">import Random
Random.seed!(1234)
x = rand(Float64,num_free_dofs(Ug))
uh0 = FEFunction(Ug,x)
uh, = solve!(uh0,solver,op)</code></pre><p>We finish this tutorial by writing the computed solution for visualization (see next figure).</p><pre><code class="language-julia">writevtk(trian,&quot;results&quot;,cellfields=[&quot;uh&quot;=&gt;uh])</code></pre><p><img src="../../assets/t0041_p_laplacian/sol-plap.png" alt/></p><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../t003_elasticity/"><span class="direction">Previous</span><span class="title">3 Linear elasticity</span></a><a class="next" href="../t004_hyperelasticity/"><span class="direction">Next</span><span class="title">5 Hyper-elasticity</span></a></footer></article></body></html>
