<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1 Poisson equation · Gridap tutorials</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gridap tutorials</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Introduction</a></li><li class="current"><a class="toctext" href>1 Poisson equation</a><ul class="internal"><li><a class="toctext" href="#Problem-statement-1">Problem statement</a></li><li><a class="toctext" href="#Numerical-scheme-1">Numerical scheme</a></li><li><a class="toctext" href="#Setup-1">Setup</a></li><li><a class="toctext" href="#Discrete-model-1">Discrete model</a></li><li><a class="toctext" href="#FE-spaces-1">FE spaces</a></li><li><a class="toctext" href="#Numerical-integration-1">Numerical integration</a></li><li><a class="toctext" href="#Weak-form-1">Weak form</a></li><li><a class="toctext" href="#FE-Problem-1">FE Problem</a></li><li><a class="toctext" href="#Solver-phase-1">Solver phase</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li><li><a class="toctext" href="../t002_validation/">2 Code validation</a></li><li><a class="toctext" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="toctext" href="../t0041_p_laplacian/">4 p-Laplacian</a></li><li><a class="toctext" href="../t004_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="toctext" href="../t005_dg_discretization/">6 Poisson equation (with DG)</a></li><li><a class="toctext" href="../t007_darcy/">7 Darcy equation (with RT)</a></li><li><a class="toctext" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>1 Poisson equation</a></li></ul><a class="edit-page" href="https://github.com/gridap/Tutorials/blob/master/src/t001_poisson.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>1 Poisson equation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-1:-Poisson-equation-1" href="#Tutorial-1:-Poisson-equation-1">Tutorial 1: Poisson equation</a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t001_poisson.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t001_poisson.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will learn</p><ul><li>How to solve a simple PDE in Julia with Gridap</li><li>How to load a discrete model (aka a FE mesh) from a file</li><li>How to build a conforming Lagrangian FE space</li><li>How to define the different terms in a weak form</li><li>How to impose Dirichlet and Neumann boundary conditions</li><li>How to visualize results</li></ul><h2><a class="nav-anchor" id="Problem-statement-1" href="#Problem-statement-1">Problem statement</a></h2><p>In this first tutorial, we provide an overview of a complete simulation pipeline in Gridap: from the construction of the FE mesh to the visualization of the computed results. To this end, we consider a simple model problem: the Poisson equation.  We want to solve the Poisson equation on the 3D domain depicted in next figure with Dirichlet and Neumann boundary conditions. Dirichlet boundary conditions are applied on <span>$\Gamma_{\rm D}$</span>, being the outer sides of the prism (marked in red). Non-homogeneous Neumann conditions are applied to the internal boundaries <span>$\Gamma_{\rm G}$</span>, <span>$\Gamma_{\rm Y}$</span>, and <span>$\Gamma_{\rm B}$</span> (marked in green, yellow and blue respectively). And homogeneous Neumann boundary conditions are applied in <span>$\Gamma_{\rm W}$</span>, the remaining portion of the boundary (marked in white).</p><p><img src="../../assets/t001_poisson/model-r1-2.png" alt/></p><p>Formally, the problem to solve is: find the scalar field <span>$u$</span> such that</p><div>\[\left\lbrace
\begin{aligned}
-\Delta u = f  \ &amp;\text{in} \ \Omega,\\
u = g \ &amp;\text{on}\ \Gamma_{\rm D},\\
\nabla u\cdot n = h \ &amp;\text{on}\  \Gamma_{\rm N},\\
\end{aligned}
\right.\]</div><p>being <span>$n$</span> the outwards unit normal vector to the Neumann boundary <span>$\Gamma_{\rm N} \doteq \Gamma_{\rm G}\cup\Gamma_{\rm Y}\cup\Gamma_{\rm B}\cup\Gamma_{\rm W}$</span>. In this example, we chose <span>$f(x) = 1$</span>, <span>$g(x) = 2$</span>, and <span>$h(x)=3$</span> on <span>$\Gamma_{\rm G}\cup\Gamma_{\rm Y}\cup\Gamma_{\rm B}$</span> and <span>$h(x)=0$</span> on <span>$\Gamma_{\rm W}$</span>. The variable <span>$x$</span> is the position vector <span>$x=(x_1,x_2,x_3)$</span>.</p><h2><a class="nav-anchor" id="Numerical-scheme-1" href="#Numerical-scheme-1">Numerical scheme</a></h2><p>To solve this PDE, we use a conventional Galerkin finite element (FE) method with conforming Lagrangian FE spaces (see, e.g., [1] for specific details on this formulation). The weak form associated with this formulation is: find <span>$u\in U_g$</span> such that $ a(v,u) = b(v) $ for all <span>$v\in V_0$</span>, where <span>$U_g$</span> and <span>$V_0$</span> are the subset of functions in <span>$H^1(\Omega)$</span> that fulfill the Dirichlet boundary condition <span>$g$</span> and <span>$0$</span> respectively. The bilinear and linear forms for this problems are</p><div>\[  a(v,u) \doteq \int_{\Omega} \nabla v \cdot \nabla u \ {\rm d}\Omega, \quad b(v) \doteq \int_{\Omega} v\ f  \ {\rm  d}\Omega + \int_{\Gamma_{\rm N}} v\ h \ {\rm d}\Gamma_{\rm N}.\]</div><p>The problem is solved numerically by approximating the spaces <span>$U_g$</span> and <span>$V_0$</span> by their discrete counterparts associated with a FE mesh of the computational domain <span>$\Omega$</span>. As we have anticipated, we consider standard conforming Lagrangian FE spaces for this purpose.</p><p>The implementation of this numerical scheme in Gridap is done in a user-friendly way thanks to the abstractions provided by the library. As it will be seen below, all the mathematical objects involved in the definition of the discrete weak problem have a correspondent representation in the code.</p><h2><a class="nav-anchor" id="Setup-1" href="#Setup-1">Setup</a></h2><p>The step number 0 in order to solve the problem is to load the Gridap library in the code. If you have configured your Julia environment properly (see \sect{sec:installing_gridap}), it is simply done with the line:</p><pre><code class="language-julia">using Gridap</code></pre><h2><a class="nav-anchor" id="Discrete-model-1" href="#Discrete-model-1">Discrete model</a></h2><p>As in any FE simulation, we need a discretization of the computational domain (i.e., a FE mesh). All geometrical data needed for solving a FE problem is provided in Gridap by types inheriting from the abstract type <code>DiscreteModel</code>. In the following line, we build an instance of <code>DiscreteModel</code> by loading a <code>json</code> file.</p><pre><code class="language-julia">model = DiscreteModelFromFile(&quot;../models/model.json&quot;)</code></pre><p>The file <code>&quot;model.json&quot;</code> is a regular <code>json</code> file that includes a set of fields that describe the discrete model. It was generated by using together the <a href="http://gmsh.info/">GMSH</a> mesh generator and the <a href="https://github.com/gridap/GridapGmsh.jl">GridapGmsh</a> package. First, we generate a <code>&quot;model.msh&quot;</code> file with GMSH (which contains a FE mesh and information about user-defined physical boundaries in {GMSH} format). Then, this file is converted to the Gridap-compatible <code>&quot;model.json&quot;</code> file using the conversion tools available in the GridapGmsh package. See the documentation of the <a href="https://github.com/gridap/GridapGmsh.jl">GridapGmsh</a> for more information.</p><p>You can easily inspect the generated discrete model in <a href="https://www.paraview.org/">Paraview</a> by writing it in <code>vtk</code> format.</p><pre><code class="language-julia">writevtk(model,&quot;model&quot;)</code></pre><p>The previous line generates four different files <code>model_0.vtu</code>, <code>model_1.vtu</code>, <code>model_2.vtu</code>, and <code>model_3.vtu</code> containing the vertices, edges, faces, and cells present in the discrete model. Moreover, you can easily inspect which boundaries are defined within the model.</p><p>For instance, if you want to see which faces of the model are on the boundary <span>$\Gamma_{\rm B}$</span> (i.e., the walls of the circular perforation), open the file <code>model_2.vtu</code> and chose coloring by the element field &quot;circle&quot;. You should see that only the faces on the circular hole have a value different from zero (see next figure).</p><p><img src="../../assets/t001_poisson/fig_faces_on_circle.png" alt/></p><p>It is also possible to see which vertices are on the Dirichlet boundary <span>$\Gamma_{\rm D}$</span>. To do so, open the file <code>model_0.vtu</code> and chose coloring by the field &quot;sides&quot; (see next figure).</p><p><img src="../../assets/t001_poisson/fig_vertices_on_sides.png" alt/></p><p>That is, the boundary <span>$\Gamma_{\rm B}$</span> (i.e., the walls of the circular hole) is called &quot;circle&quot; and the Dirichlet boundary <span>$\Gamma_{\rm D}$</span> is called &quot;sides&quot; in the model. In addition, the walls of the triangular hole <span>$\Gamma_{\rm G}$</span> and the walls of the square hole <span>$\Gamma_{\rm Y}$</span> are identified in the model with the names &quot;triangle&quot; and &quot;square&quot; respectively. You can easily check this by opening the corresponding file in Paraview.</p><h2><a class="nav-anchor" id="FE-spaces-1" href="#FE-spaces-1">FE spaces</a></h2><p>Once we have a discretization of the computational domain, the next step is to generate a discrete approximation of the finite element spaces <span>$V_0$</span> and <span>$U_g$</span> (i.e. the test and trial FE spaces) of the problem. To do so, first, we are going to build a discretization of <span>$V\doteq H^1(\Omega)$</span> as the standard Conforming Lagrangian FE space (without boundary conditions) associated with the discretization of the computational domain. The approximation of the FE space <span>$V$</span> is build as follows:</p><pre><code class="language-julia">V = FESpace(
  reffe=:Lagrangian, order=1, valuetype=Float64,
  conformity=:H1, model=model, diritags=&quot;sides&quot;)</code></pre><p>Here, we have used the <code>FESpace</code> constructor, which constructs a particular FE space from a set of options described as key-word arguments. The with the options <code>reffe=:Lagrangian</code>, <code>order=1</code>, and  <code>valuetype=Float64</code>, we define the local interpolation at the reference FE element. In this case, we select a scalar-valued, first order, Lagrangian interpolation. In particular, the value of the shape functions will be represented with  64-bit floating point numbers. With the key-word argument <code>conformity</code> we define the regularity of the interpolation at the boundaries of the cells in the mesh. Here, we use <code>conformity=:H1</code>, which means that the resulting interpolation space is a subset of <span>$H^1(\Omega)$</span> (i.e., continuous shape functions). On the other hand, with the key-word argument <code>model</code>, we select the discrete model on top of which we want to construct the FE space. Finally, we pass the identifiers of the Dirichlet boundary via the <code>diritags</code> argument. In this case, we mark as Dirichlet all objects of the discrete model identified with the <code>&quot;sides&quot;</code> tag. Note that, even though functions in <span>$V$</span> are not constrained by Dirichlet boundary conditions, the underlying implementation is aware of which functions have support on the Dirichlet boundary. This is why we need to pass the argument <code>diritags</code>.</p><p>Once the space <span>$V$</span> is discretized in the code, we proceed with the approximation of the test and trial spaces <span>$V_0$</span> and <span>$U_g$</span>.</p><pre><code class="language-julia">g(x) = 2.0
V0 = TestFESpace(V)
Ug = TrialFESpace(V,g)</code></pre><p>To this end, we have used the <code>TestFESpace</code> and <code>TrialFESpace</code> constructors. Note that we have passed a function representing the value of the Dirichlet boundary condition, when building the trial space. This is not necessary for the test space, since functions in the test space are always constrained to 0 on the Dirichlet boundary.</p><h2><a class="nav-anchor" id="Numerical-integration-1" href="#Numerical-integration-1">Numerical integration</a></h2><p>Once we have built the interpolation spaces, the next step is to set up the machinery to perform the integrals in the weak form numerically. Here, we need to compute integrals on the interior of the domain <span>$\Omega$</span> and on the Neumann boundary <span>$\Gamma_{\rm N}$</span>. In both cases, we need two main ingredients. We need to define an integration mesh (i.e. a triangulation of the integration domain), plus a Gauss-like quadrature in each of the cells in the triangulation. In Gridap, integration meshes are represented by types inheriting from the abstract type <code>Triangulation</code>. For integrating on the domain <span>$\Omega$</span>, we build the following triangulation and quadrature:</p><pre><code class="language-julia">trian = Triangulation(model)
quad = CellQuadrature(trian,degree=2)</code></pre><p>Here, we build a triangulation from the cells of the model and define a quadrature of degree  2 in the cells of this triangulation. This is enough for integrating the corresponding terms of the weak form exactly for an interpolation of order 1.</p><p>On the other hand, we need a special type of triangulation, represented by the type	 <code>BoundaryTriangulation</code>, to integrate on the boundary. Essentially, a  <code>BoundaryTriangulation</code> is a particular type of <code>Triangulation</code> that is aware of which cells in the model are touched by faces on the boundary. We build an instance of this type from the discrete model and the names used to identify the Neumann boundary as follows:</p><pre><code class="language-julia">neumanntags = [&quot;circle&quot;, &quot;triangle&quot;, &quot;square&quot;]
btrian = BoundaryTriangulation(model,neumanntags)
bquad = CellQuadrature(btrian,degree=2)</code></pre><p>In addition, we have created a quadrature of degree 2 on top of the cells in the triangulation for the Neumann boundary.</p><h2><a class="nav-anchor" id="Weak-form-1" href="#Weak-form-1">Weak form</a></h2><p>With all the ingredients presented so far, we are ready to define the weak form. This is done by means of types inheriting from the abstract type <code>FETerm</code>. In this tutorial, we will use the sub-types <code>AffineFETerm</code> and <code>FESource</code>. An <code>AffineFETerm</code> is a term that contributes both to the system matrix and the right-hand-side vector, whereas a <code>FESource</code> only contributes to the right hand side vector. Here, we use an <code>AffineFETerm</code> to represent all the terms in the weak form that are integrated over the interior of the domain <span>$\Omega$</span>.</p><pre><code class="language-julia">f(x) = 1.0
a(v,u) = inner( ∇(v), ∇(u) )
b_Ω(v) = inner(v, f)
t_Ω = AffineFETerm(a,b_Ω,trian,quad)</code></pre><p>In the first argument of the <code>AffineFETerm</code> constructor, we pass a function that represents the integrand of the bilinear form <span>$a(\cdot,\cdot)$</span>. The second argument is a function that represents the integrand of the part of the linear form <span>$b(\cdot)$</span> that is integrated over the domain <span>$\Omega$</span>. The third argument is the <code>Triangulation</code> on which we want to perform the integration (in that case the integration mesh for <span>$\Omega$</span>), and the last argument is the <code>CellQuadrature</code> needed to perform the integration numerically. Since the contribution of the Neumann boundary condition is integrated over a different domain, it cannot be included in the previous <code>AffineFETerm</code>. To account for it, we use a <code>FESource</code>:</p><pre><code class="language-julia">h(x) = 3.0
b_Γ(v) = inner(v, h)
t_Γ = FESource(b_Γ,btrian,bquad)</code></pre><p>In the first argument of the <code>FESource</code> constructor, we pass a function representing the integrand of the Neumann boundary condition. In the two last arguments we pass the triangulation and quadrature for the Neumann boundary.</p><h2><a class="nav-anchor" id="FE-Problem-1" href="#FE-Problem-1">FE Problem</a></h2><p>At this point, we can build the FE problem that, once solved, will provide the numerical solution we are looking for. A FE problem is represented in Gridap by types inheriting from the abstract type <code>FEOperator</code> (both for linear and nonlinear cases). Since we want to solve a linear problem, we use the concrete type <code>LinearFEOperator</code>.</p><pre><code class="language-julia">op = LinearFEOperator(V0,Ug,t_Ω,t_Γ)</code></pre><p>Note that the <code>LinearFEOperator</code> object representing our FE problem is built from the test and trial FE spaces <code>V0</code> and <code>Ug</code>, and the objects <code>t_Ω</code> and <code>t_Γ</code> representing the weak form.</p><h2><a class="nav-anchor" id="Solver-phase-1" href="#Solver-phase-1">Solver phase</a></h2><p>We have constructed a FE problem, the last step is to solve it. In Gridap, FE problems are solved with types inheriting from the abstract type <code>FESolver</code>. Since this is a linear problem, we use a <code>LinearFESolver</code>:</p><pre><code class="language-julia">ls = LUSolver()
solver = LinearFESolver(ls)</code></pre><p><code>LinearFESolver</code> objects are build from a given algebraic linear solver. In this case, we use a LU factorization. Now we are ready to solve the FE problem with the FE solver as follows:</p><pre><code class="language-julia">uh = solve(solver,op)</code></pre><p>The <code>solve</code> function returns the computed numerical solution <code>uh</code>. This object is an instance of <code>FEFunction</code>, the type used to represent a function in a FE space. We can inspect the result by writing it into a <code>vtk</code> file:</p><pre><code class="language-julia">writevtk(trian,&quot;results&quot;,cellfields=[&quot;uh&quot;=&gt;uh])</code></pre><p>which will generate a file named <code>results.vtu</code> having a nodal field named <code>&quot;uh&quot;</code> containing the solution of our problem (see next figure).</p><p><img src="../../assets/t001_poisson/fig_uh.png" alt/></p><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><p>[1] C. Johnson. <em>Numerical Solution of Partial Differential Equations by the Finite Element Method</em>. Dover Publications, 2009.</p><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="../t002_validation/"><span class="direction">Next</span><span class="title">2 Code validation</span></a></footer></article></body></html>
