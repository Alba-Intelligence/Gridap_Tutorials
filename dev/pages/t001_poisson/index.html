<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1 Poisson equation · Gridap tutorials</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gridap tutorials</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Introduction</a></li><li class="current"><a class="toctext" href>1 Poisson equation</a><ul class="internal"><li><a class="toctext" href="#Learning-outcomes-1">Learning outcomes</a></li><li><a class="toctext" href="#Problem-statement-1">Problem statement</a></li><li><a class="toctext" href="#Numerical-scheme-1">Numerical scheme</a></li><li><a class="toctext" href="#Implementation-1">Implementation</a></li><li><a class="toctext" href="#Summary-1">Summary</a></li></ul></li><li><a class="toctext" href="../t002_validation/">2 Code validation</a></li><li><a class="toctext" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="toctext" href="../t0041_p_laplacian/">4 p-Laplacian</a></li><li><a class="toctext" href="../t004_hyperelasticity/">5 Hyper-elasticity</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>1 Poisson equation</a></li></ul><a class="edit-page" href="https://github.com/gridap/Tutorials/blob/master/src/t001_poisson.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>1 Poisson equation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-1:-Poisson-equation-1" href="#Tutorial-1:-Poisson-equation-1">Tutorial 1: Poisson equation</a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t001_poisson.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t001_poisson.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><h2><a class="nav-anchor" id="Learning-outcomes-1" href="#Learning-outcomes-1">Learning outcomes</a></h2><ul><li>How to solve a simple PDE in Julia with Gridap</li><li>How to load a discrete model (aka a FE mesh) from a file</li><li>How to build Conforming Lagrangian FE spaces</li><li>How to define the different terms in a weak form</li><li>How to impose Dirichlet and Neumann boundary conditions</li><li>How to visualize results</li></ul><h2><a class="nav-anchor" id="Problem-statement-1" href="#Problem-statement-1">Problem statement</a></h2><p>We want to solve the Poisson equation on the 3D domain depicted in the figure below with Dirichlet and Neumann boundary conditions. Dirichlet boundary conditions are applied on <span>$\Gamma_{\rm D}$</span>, being the outer sides of the prism (marked in red). Non-homogeneous Neumann conditions are applied to the internal boundaries <span>$\Gamma_{\rm G}$</span>, <span>$\Gamma_{\rm Y}$</span>, and <span>$\Gamma_{\rm B}$</span> (marked in green, yellow and blue respectively). And homogeneous Neumann boundary conditions are applied in <span>$\Gamma_{\rm W}$</span>, the remaining portion of the boundary (marked in white).</p><p><img src="../../models/model-r1.png" alt="model"/></p><p>Formally, the problem to solve is: find <span>$u$</span> such that</p><div>\[\left\lbrace
\begin{aligned}
-\Delta u = f  \ \text{in} \ \Omega\\
u = g \ \text{on}\ \Gamma_{\rm D}\\
\nabla u\cdot n = h \ \text{on}\  \Gamma_{\rm N}\\
\end{aligned}
\right.\]</div><p>being <span>$n$</span> the outwards unit normal vector to the Neumann boundary <span>$\Gamma_{\rm N} \doteq \Gamma_{\rm G}\cup\Gamma_{\rm Y}\cup\Gamma_{\rm B}\cup\Gamma_{\rm W}$</span>. For simplicity, we chose <span>$f(x) = 1$</span>, <span>$g(x) = 2$</span>, and <span>$h(x)=3$</span> on <span>$\Gamma_{\rm G}\cup\Gamma_{\rm Y}\cup\Gamma_{\rm B}$</span> and <span>$h(x)=0$</span> on <span>$\Gamma_{\rm W}$</span>. The variable <span>$x$</span> is the position vector <span>$x=(x_1,x_2,x_3)$</span>.</p><h2><a class="nav-anchor" id="Numerical-scheme-1" href="#Numerical-scheme-1">Numerical scheme</a></h2><p>In this first tutorial, we use a conventional Galerkin finite element (FE) method with conforming Lagrangian finite element spaces. The model problem reduces to the weak equation: find <span>$u\in U_g$</span> such that $ a(v,u) = b(v) $ for all <span>$v\in V_0$</span>, where <span>$U_g$</span> and <span>$V_0$</span> are the subset of functions in <span>$H^1(\Omega)$</span> that fulfill the Dirichlet boundary condition <span>$g$</span> and <span>$0$</span> respectively. The bilinear and linear forms for this problems are</p><div>\[a(v,u) \doteq \int_{\Omega} \nabla v \cdot \nabla u \ {\rm d}\Omega, \quad b(v) \doteq \int_{\Omega} v\ f  \ {\rm  d}\Omega + \int_{\Gamma_{\rm N}} v\ g \ {\rm d}\Gamma_{\rm N}\]</div><h2><a class="nav-anchor" id="Implementation-1" href="#Implementation-1">Implementation</a></h2><p>In order to solve this problem in Gridap,  we are going to build the main objects that are involved in the weak formulation.  The step number 0 is to load the Gridap project. If you have configured your environment properly, it is simply done like this:</p><pre><code class="language-julia">using Gridap</code></pre><h3><a class="nav-anchor" id="Discrete-model-1" href="#Discrete-model-1">Discrete model</a></h3><p>As in any FE simulation, we need a discretization of the computational domain (i.e a FE mesh), which contains information of the different boundaries to impose boundary conditions. All geometrical data needed for solving a FE problem is provided in Gridap by types inheriting from the abstract type <code>DiscreteModel</code>. In the following line, we build an instance of <code>DiscreteModel</code> by loading a model from a <code>json</code> file.</p><pre><code class="language-julia">model = DiscreteModelFromFile(&quot;../models/model.json&quot;);</code></pre><p>You can easily inspect the generated model in Paraview by writing it in <code>vtk</code> format.</p><pre><code class="language-julia">writevtk(model,&quot;model&quot;);</code></pre><p>The previous line generates four different files <code>model_0.vtu</code>, <code>model_1.vtu</code>, <code>model_2.vtu</code>, and <code>model_3.vtu</code> containing the vertices, edges, faces, and cells present in the discrete model. Moreover, you can easily inspect which boundaries are defined within the model.</p><p>For instance, if we want to see which faces of the model are on the boundary <span>$\Gamma_{\rm B}$</span> (i.e., the walls of the circular hole), open the file <code>model_2.vtu</code> and chose coloring by the element field &quot;circle&quot;. You should see that only the faces on the circular hole have a value different from 0.</p><p><img src="../../assets/t001_poisson/fig_faces_on_circle.png" alt/></p><p>It is also possible to see which vertices are on the Dirichlet boundary <span>$\Gamma_{\rm D}$</span>. To do so, open the file <code>model_0.vtu</code> and chose coloring by the field &quot;sides&quot;.</p><p><img src="../../assets/t001_poisson/fig_vertices_on_sides.png" alt/></p><p>That is, the boundary <span>$\Gamma_{\rm B}$</span> (i.e., the walls of the circular hole) is called &quot;circle&quot; and the Dirichlet boundary <span>$\Gamma_{\rm D}$</span> is called &quot;sides&quot; in the model. In addition, the walls of the triangular hole <span>$\Gamma_{\rm G}$</span> and the walls of the square hole <span>$\Gamma_{\rm Y}$</span> are identified in the model with the names &quot;triangle&quot; and &quot;square&quot; respectively.</p><h3><a class="nav-anchor" id="FE-spaces-1" href="#FE-spaces-1">FE spaces</a></h3><p>Once we have a discretization of the computational domain, the next step is to generate a discrete approximation of the finite element spaces <span>$V_0$</span> and <span>$U_g$</span> (i.e. the test and trial FE spaces) of the problem. To do so, first, we are going to build a discretization of <span>$H^1(\Omega)$</span>, namely <span>$V$</span>, defined as the standard Conforming Lagrangian FE space (without boundary conditions) associated with the discretization of the computational domain. Note that functions in <span>$V$</span> are free on the Dirichlet boundary (which is not the case for <span>$V_0$</span> and <span>$U_g$</span>). The FE space <span>$V$</span> is build as follows:</p><pre><code class="language-julia">order = 1
diritag = &quot;sides&quot;
V = CLagrangianFESpace(Float64,model,order,diritag);</code></pre><p>In the first argument, we pass the data type that represents the value of the functions in the space. In that case, <code>Float64</code> since the unknown of our problem is scalar-valued and it will be represented with a 64-bit floating point number. In addition, we pass the model on top of which we want to construct the space, the interpolation order, and the name of the entities that are on the Dirichlet boundary. Note that, even though functions in <span>$V$</span> are not constrained by Dirichlet boundary conditions, the underlaying implementation is aware of which functions have support on the Dirichlet boundary. This is why we need to pass the argument <code>diritag</code>.</p><p>The approximations for the test and trial spaces <span>$V_0$</span> and <span>$U_g$</span> are build simply as</p><pre><code class="language-julia">g(x) = 2.0
V0 = TestFESpace(V)
Ug = TrialFESpace(V,g);</code></pre><p>Note that functions in the test space are always constrained to 0 on the Dirichlet boundary, whereas functions on the trial space are constrained to the given boundary function. In this case, function <span>$g$</span>.</p><h3><a class="nav-anchor" id="Numerical-integration-1" href="#Numerical-integration-1">Numerical integration</a></h3><p>Once we have build the interpolation spaces, the next step is to set up the machinery to perform the integrals in the weak form numerically. Here, we need to compute integrals on the interior of the domain <span>$\Omega$</span> and on the Neumann boundary <span>$\Gamma_{\rm N}$</span>. In both cases, we need two main ingredients. We need to define an integration mesh (i.e. a set of cells that form a partition of the integration domain), plus a Gauss-like quadrature in each of the cells. In Gridap, integration meshes are represented by types inheriting from the abstract type <code>Triangulation</code>. For integrating on the domain <span>$\Omega$</span>, we build the following integration mesh and quadrature:</p><pre><code class="language-julia">trian = Triangulation(model)
quad = CellQuadrature(trian,order=2);</code></pre><p>Note that in this simple case, we are using the cells of the model as integration cells, but in more complex formulations (e.g., embedded finite element computations) the integration cells can be different from the cells on the background FE mesh. Note also, that we are constructing a quadrature of order 2 in the cells of the integration mesh. This is enough for integrating all terms of the weak form exactly for an interpolation of order 1.</p><p>On the other hand, we need a special type of integration mesh, represented by the type <code>BoundaryTriangulation</code>, to integrate on the boundary. We build an instance of this type from the discrete model and the names used to identify the Neumann boundary as follows:</p><pre><code class="language-julia">neumanntags = [&quot;circle&quot;, &quot;triangle&quot;, &quot;square&quot;]
btrian = BoundaryTriangulation(model,neumanntags)
bquad = CellQuadrature(btrian,order=2);</code></pre><p>Note that we have also created a quadrature of order 2 on top of the integration mesh for the Neumann boundary.</p><h3><a class="nav-anchor" id="Weak-form-1" href="#Weak-form-1">Weak form</a></h3><p>With all the ingredients presented so far, we are ready to define our FE problem.  First, we need to define the weak form of the problem at hand. This is done by means of types inheriting from the abstract type <code>FETerm</code>. In this tutorial, we will use the sub-types <code>AffineFETerm</code> and <code>FESource</code>. An <code>AffineFETerm</code> is a term that contributes both to the system matrix and the right-hand-side vector, whereas a <code>FESource</code> only contributes to the right hand side vector.</p><p>In this example, we use an <code>AffineFETerm</code> to represent all the terms in the weak form that are integrated over the interior of the domain <span>$\Omega$</span>. It is constructed like this:</p><pre><code class="language-julia">f(x) = 1.0
a(v,u) = inner( ∇(v), ∇(u) )
b_Ω(v) = inner(v, f)
t_Ω = AffineFETerm(a,b_Ω,trian,quad);</code></pre><p>In the first argument, we pass a function that represents the integrand of the bilinear form <span>$a(\cdot,\cdot)$</span>, the second argument is a function that represents the integrand of part of the billinar form <span>$b(\cdot)$</span> that is integrated over the domain <span>$\Omega$</span>. The third argument is the <code>Triangulation</code> on which we want to perform the integration (in that case the integration mesh for <span>$\Omega$</span>), and the last argument is the <code>CellQuadrature</code> needed to perform the integration numerically.</p><p>Note that the contribution associated with the Neumann condition is integrated over a different domain, and thus, cannot be included in the previous <code>AffineFETerm</code>. To account for it, we use a <code>FESource</code> object:</p><pre><code class="language-julia">h(x) = 3.0
b_Γ(v) = inner(v, h)
t_Γ = FESource(b_Γ,btrian,bquad);</code></pre><p>Here, we pass in the first argument the integrand of the Neumann boundary condition, and in the last arguments we pass the integration mesh and quadrature for the Neumann boundary.</p><p>Presenting the precise notation used to define the integrands of the weak form is out of the scope of this first tutorial. But for the moment, the following remarks are enough. Variables <code>v</code> and <code>u</code>  represents a test and trial function respectively. The function <code>∇</code> represents the gradient operator. The function <code>inner</code> represents the inner product. It is extremely important to be aware that the <em>implementation</em> of the <code>inner</code> function is not commutative! The first argument is always for the test function (which will be associated with the rows of the system matrix or the right hand side vector depending on the case). Not following this rule can end up with matrices that are the transpose of the matrix you really want or with code crashes in the worst case. Note that we have always correctly placed the test function <code>v</code> in the first argument.</p><h3><a class="nav-anchor" id="FE-problem-1" href="#FE-problem-1">FE problem</a></h3><p>At this point, we can combine all ingredients and formulate our FE problem. A FE problem (both for linear and nonlinear cases) is represented in the code by types inheriting from the abstract type <code>FEOperator</code>. Since we want to solve a linear problem, we use the concrete type <code>LinearFEOperator</code>:</p><pre><code class="language-julia">assem = SparseMatrixAssembler(V0,Ug)
op = LinearFEOperator(V0,Ug,assem,t_Ω,t_Γ);</code></pre><p>Note that we build the <code>LinearFEOperator</code> object from the test and trial FE spaces and the FE terms constructed before. We also need to provide an <code>Assembler</code> object, which represents the strategy to assemble the system. In this case, we use a <code>SparseMatrixAssembler</code>, which will use Julia build-in sparse matrices.</p><h3><a class="nav-anchor" id="Solver-phase-1" href="#Solver-phase-1">Solver phase</a></h3><p>We have constructed a FE problem, the last step is to solve it. In Gridap, FE problems are solved with types inheriting from the abstract type <code>FESolver</code>. Since this is a linear problem, we use a <code>LinearFESolver</code>:</p><pre><code class="language-julia">ls = LUSolver()
solver = LinearFESolver(ls)</code></pre><p><code>LinearFESolver</code> objects are build from a given algebraic linear solver. In this case, we use a LU factorization. Now we are ready to solve the problem as follows:</p><pre><code class="language-julia">uh = solve(solver,op);</code></pre><p>The solution of the problem <code>uh</code> is an instance of <code>FEFunction</code>, the type used to represent a function in a FE space. We can inspect the result by writing it into a vtk file:</p><pre><code class="language-julia">writevtk(trian,&quot;results&quot;,cellfields=[&quot;uh&quot;=&gt;uh]);</code></pre><p>which will generate a file named <code>results.vtu</code> having a nodal field named <code>uh</code> containing the solution of our problem. If you open it, you will see something like this:</p><p><img src="../../assets/t001_poisson/fig_uh.png" alt/></p><h2><a class="nav-anchor" id="Summary-1" href="#Summary-1">Summary</a></h2><p>Since this has been a quite long tutorial, we end up by wrapping all the code we have used.</p><pre><code class="language-julia">using Gridap

#Read the discrete model
model = DiscreteModelFromFile(&quot;../models/model.json&quot;)

#Setup FE space
order = 1
diritag = &quot;sides&quot;
V = CLagrangianFESpace(Float64,model,order,diritag)

#Setup test and trial spaces
g(x) = 2.0
V0 = TestFESpace(V)
Ug = TrialFESpace(V,g)

#Setup numerical integration (volume)
trian = Triangulation(model)
quad = CellQuadrature(trian,order=2)

#Setup numerical integration (boundary)
neumanntags = [&quot;circle&quot;, &quot;triangle&quot;, &quot;square&quot;]
btrian = BoundaryTriangulation(model,neumanntags)
bquad = CellQuadrature(btrian,order=2)

#Setup FE terms (volume)
f(x) = 1.0
a(v,u) = inner( ∇(v), ∇(u) )
b_Ω(v) = inner(v, f)
t_Ω = AffineFETerm(a,b_Ω,trian,quad)

#Setup FE terms (boundary)
h(x) = 3.0
b_Γ(v) = inner(v, h)
t_Γ = FESource(b_Γ,btrian,bquad)

#Setup FE problem
assem = SparseMatrixAssembler(V0,Ug)
op = LinearFEOperator(V0,Ug,assem,t_Ω,t_Γ)

#Solve it!
ls = LUSolver()
solver = LinearFESolver(ls)
uh = solve(solver,op)

#Write results
writevtk(trian,&quot;results&quot;,cellfields=[&quot;uh&quot;=&gt;uh])</code></pre><p>Congrats, tutorial done!</p><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="../t002_validation/"><span class="direction">Next</span><span class="title">2 Code validation</span></a></footer></article></body></html>
