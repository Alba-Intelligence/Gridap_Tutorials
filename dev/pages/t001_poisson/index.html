<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1 Poisson equation · Gridap tutorials</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gridap tutorials</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Introduction</a></li><li class="current"><a class="toctext" href>1 Poisson equation</a><ul class="internal"><li><a class="toctext" href="#Problem-statement-1">Problem statement</a></li><li><a class="toctext" href="#Numerical-scheme-1">Numerical scheme</a></li><li><a class="toctext" href="#Implementation-1">Implementation</a></li></ul></li><li><a class="toctext" href="../t002_elasticity/">2 Linear elasticity</a></li><li><a class="toctext" href="../t003_hyperelasticity/">3 Hyper-elasticity</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>1 Poisson equation</a></li></ul><a class="edit-page" href="https://github.com/gridap/Tutorials/blob/master/src/t001_poisson.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>1 Poisson equation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-1:-Poisson-equation-1" href="#Tutorial-1:-Poisson-equation-1">Tutorial 1: Poisson equation</a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t001_poisson.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t001_poisson.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><h2><a class="nav-anchor" id="Problem-statement-1" href="#Problem-statement-1">Problem statement</a></h2><p>We want to solve the Possion equation on the 3D domain depicted in the figure below with Dirichlet and Neumann boundary conditions. Dirichlet boundary conditions are applyed on <span>$\Gamma_{\rm D}$</span>, being the outer sides of the prism (marked in red). Non-homogeneous Neumann conditions are applyed to the internal boundaries <span>$\Gamma_{\rm G}$</span>, <span>$\Gamma_{\rm Y}$</span>, and <span>$\Gamma_{\rm B}$</span> (marked in green, yelow and blue respectively). And homogeneous Neumann boundary conditions are applyed in <span>$\Gamma_{\rm W}$</span>, the remaining portion of the boundary (marked in white).</p><p><img src="../../models/model-r1.png" alt="model"/></p><p>Formally, the problem to solve is: find <span>$u$</span> such that</p><div>\[\left\lbrace
\begin{aligned}
-\Delta u = f  \ \text{in} \ \Omega\\
u = g \ \text{on}\ \Gamma_{\rm D}\\
\nabla u\cdot n = h \ \text{on}\  \Gamma_{\rm N}\\
\end{aligned}
\right.\]</div><p>being <span>$n$</span> the outwards unit normal vector to the Neumann boundary <span>$\Gamma_{\rm N} \doteq \Gamma_{\rm G}\cup\Gamma_{\rm Y}\cup\Gamma_{\rm B}\cup\Gamma_{\rm W}$</span>. For simplicity, we chose <span>$f(x) = 1$</span>, <span>$g(x) = 2$</span>, and <span>$h(x)=3$</span> on <span>$\Gamma_{\rm G}\cup\Gamma_{\rm Y}\cup\Gamma_{\rm B}$</span> and <span>$h(x)=0$</span> on <span>$\Gamma_{\rm W}$</span>. The variable <span>$x$</span> is the position vector <span>$x=(x_1,x_2,x_3)$</span>.</p><h2><a class="nav-anchor" id="Numerical-scheme-1" href="#Numerical-scheme-1">Numerical scheme</a></h2><p>In this first tutorial, we use a conventional Galerkin finite element (FE) method with conforming Lagrangian finite element spaces. In that case, the model problem reduces to the weak equation: find <span>$u\in U_g$</span> such that $ a(v,u) = b(v) $ for all <span>$v\in V_0$</span>, where <span>$U_g$</span> and <span>$V_0$</span> are the subset of functions in <span>$H^1(\Omega)$</span> that fulfill the Dirichlet boundary condition <span>$g$</span> and <span>$0$</span> respectively. The bilinear and linear forms for this problems are</p><div>\[a(v,u) \doteq \int_{\Omega} \nabla v \cdot \nabla u \ {\rm d}\Omega, \quad b(v) \doteq \int_{\Omega} v\ f  \ {\rm  d}\Omega + \int_{\Gamma_{\rm N}} v\ g \ {\rm d}\Gamma_{\rm N}\]</div><p>While solving this problem in Gridap, we are going to build the main objects that are involved in this equation in a very inuitive way.</p><h2><a class="nav-anchor" id="Implementation-1" href="#Implementation-1">Implementation</a></h2><p>The step number 0, is to load the Gridap project. If you have followed the steps of the <code>README.md</code> file, it is simply done like this:</p><pre><code class="language-julia">using Gridap</code></pre><p>As in any FE simulation, we need a discretization of the computational domain, which, in addition, is aware of the different boundaries to impose boundary conditions. This information is provided in Gridap by objects inheriting from the abstract type <code>DiscreteModel</code>. In the following line, we build an instance of <code>DiscreteModel</code> by loading a model from a <code>json</code> file.</p><pre><code class="language-julia">model = DiscreteModelFromFile(&quot;../models/model.json&quot;);</code></pre><p>You can easily inspect the generated model in Paraview by writting it to <code>vtk</code> format.</p><pre><code class="language-julia">writevtk(model,&quot;model&quot;);</code></pre><p>Previous line generates four different files <code>model_0.vtu</code>, <code>model_1.vtu</code>, <code>model_2.vtu</code>, and <code>model_3.vtu</code> containing the vertices, edges, faces, and cells present in the discrete model. Moreover, you can easily inspect, which boundaries are defined within the model.</p><p>For instance, if we want to see which faces of the model are on the boundary <span>$\Gamma_{\rm B}$</span> (i.e., the walls of the circular hole), open the file <code>model_2.vtu</code> and chose coloring by the element field &quot;circle&quot;. You should see that only the faces on the circular hole hava a value different from 0.</p><p><img src="../../assets/t001_poisson/fig_faces_on_circle.png" alt/></p><p>On the other hand, to see which vertices are on the Dirichlet boundary <span>$\Gamma_{\rm D}$</span>, open the file <code>model_0.vtu</code> and chose coloring by the field &quot;sides&quot;.</p><p><img src="../../assets/t001_poisson/fig_vertices_on_sides.png" alt/></p><p>You can easily see, by inspecting the files in paraview, that the walls of the triangular hole <span>$\Gamma_{\rm G}$</span> and the walls of the square hole <span>$\Gamma_{\rm Y}$</span> are identified in the model with the names &quot;triangle&quot; and &quot;square&quot; respectively.</p><pre><code class="language-julia">order = 1
diritag = &quot;sides&quot;
fespace = ConformingFESpace(Float64,model,order,diritag);</code></pre><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.</p><pre><code class="language-julia">g(x) = 2.0
V = TestFESpace(fespace)
U = TrialFESpace(fespace,g);</code></pre><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.</p><pre><code class="language-julia">trian = Triangulation(model)
quad = CellQuadrature(trian,order=2);</code></pre><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.</p><pre><code class="language-julia">neumanntags = [&quot;circle&quot;, &quot;triangle&quot;, &quot;square&quot;]
btrian = BoundaryTriangulation(model,neumanntags)
bquad = CellQuadrature(btrian,order=2);</code></pre><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.</p><pre><code class="language-julia">f(x) = 1.0
a(v,u) = inner( ∇(v), ∇(u) )
b_Ω(v) = inner(v, f)
t_Ω = AffineFETerm(a,b_Ω,trian,quad);</code></pre><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.</p><pre><code class="language-julia">h(x) = 3.0
b_Γ(v) = inner(v, h)
t_Γ = FESource(b_Γ,btrian,bquad);</code></pre><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.</p><pre><code class="language-julia">assem = SparseMatrixAssembler(V,U)
op = LinearFEOperator(V,U,assem,t_Ω,t_Γ);</code></pre><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.</p><pre><code class="language-julia">ls = LUSolver()
solver = LinearFESolver(ls)
uh = solve(solver,op);</code></pre><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.</p><pre><code class="language-julia">writevtk(trian,&quot;results&quot;,cellfields=[&quot;uh&quot;=&gt;uh]);</code></pre><p><img src="../../assets/t001_poisson/fig_uh.png" alt/></p><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="../t002_elasticity/"><span class="direction">Next</span><span class="title">2 Linear elasticity</span></a></footer></article></body></html>
