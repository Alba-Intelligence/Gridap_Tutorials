<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>7 Darcy equation (with RT) · Gridap tutorials</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gridap tutorials</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Introduction</a></li><li><a class="toctext" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="toctext" href="../t002_validation/">2 Code validation</a></li><li><a class="toctext" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="toctext" href="../t0041_p_laplacian/">4 p-Laplacian</a></li><li><a class="toctext" href="../t004_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="toctext" href="../t005_dg_discretization/">6 Poisson equation (with DG)</a></li><li class="current"><a class="toctext" href>7 Darcy equation (with RT)</a><ul class="internal"><li><a class="toctext" href="#Problem-statement-1">Problem statement</a></li><li><a class="toctext" href="#Numerical-scheme-1">Numerical scheme</a></li><li><a class="toctext" href="#Discrete-model-1">Discrete model</a></li><li><a class="toctext" href="#Multi-field-FE-spaces-1">Multi-field FE spaces</a></li><li><a class="toctext" href="#Numerical-integration-1">Numerical integration</a></li><li><a class="toctext" href="#Weak-form-1">Weak form</a></li><li><a class="toctext" href="#Multi-field-FE-problem-1">Multi-field FE problem</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>7 Darcy equation (with RT)</a></li></ul><a class="edit-page" href="https://github.com/gridap/Tutorials/blob/master/src/t007_darcy.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>7 Darcy equation (with RT)</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-7:-Darcy-equation-(with-RT)-1" href="#Tutorial-7:-Darcy-equation-(with-RT)-1">Tutorial 7: Darcy equation (with RT)</a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t007_darcy.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t007_darcy.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will learn</p><ul><li>How to implement multi-field PDEs</li><li>How to build div-conforming FE spaces</li><li>How to impose boundary conditions in multi-field problems</li></ul><h2><a class="nav-anchor" id="Problem-statement-1" href="#Problem-statement-1">Problem statement</a></h2><p>In this tutorial, we show how to solve a multi-field PDE in Gridap. As a model problem, we consider the Darcy equations with Dirichlet and Neumann boundary conditions. The PDE we want to solve is: find the flux vector <span>$u$</span>, and the pressure <span>$p$</span> such that</p><div>\[   \left\lbrace
   \begin{aligned}
      \kappa^{-1} u + \nabla p = 0  \ &amp;\text{in} \ \Omega,\\
      \nabla \cdot u = f  \ &amp;\text{in} \ \Omega,\\
      u \cdot n = g \ &amp;\text{on}\  \Gamma_{\rm D},\\
      p = h \ &amp;\text{on}\ \Gamma_{\rm N},\\
   \end{aligned}
   \right.\]</div><p>being <span>$n$</span> the outwards unit normal vector to the boundary <span>$\partial\Omega$</span>.  In this particular tutorial, we consider the unit square <span>$\Omega \doteq (0,1)^2$</span> as the computational domain, the Neumann boundary <span>$\Gamma_{\rm N}$</span> is the right and left sides of <span>$\Omega$</span>, and <span>$\Gamma_{\rm D}$</span> is the bottom and top sides of <span>$\Omega$</span>. We consider <span>$f = g \doteq 0$</span> and <span>$h(x) \doteq x_1$</span>, i.e., <span>$h$</span> equal to 0 on the left side and 1 on the right side. The permeability tensor <span>$\kappa^{-1}(x)$</span> is chosen equal to</p><div>\[\begin{pmatrix}
  100 &amp; 90 \\
  90 &amp; 100
\end{pmatrix}
\text{ for } \ x \in [0.4,0.6]^2, \text{ and }
\begin{pmatrix}
  1 &amp; 0 \\
  0 &amp; 1
\end{pmatrix}
\ \text	{otherwise.}\]</div><p>In order to state this problem in weak form, we introduce the following Sobolev spaces. <span>$H(\mathrm{div};\Omega)$</span> is the space of vector fields in <span>$\Omega$</span>, whose components and divergence are in <span>$L^2(\Omega)$</span>. On the other hand, <span>$H_g(\mathrm{div};\Omega)$</span> and <span>$H_0(\mathrm{div};\Omega)$</span> are the subspaces of functions in <span>$H(\mathrm{div};\Omega)$</span> such that their normal traces are equal to <span>$g$</span> and <span>$0$</span> respectively almost everywhere in <span>$\Gamma_{\rm D}$</span>. With these notations, the weak form reads: find <span>$(u,p)\in H_g(\mathrm{div};\Omega)\times L^2(\Omega)$</span> such that <span>$a((v,q),(u,q)) = b(v,q)$</span> for all <span>$(v,q)\in H_0(\mathrm{div};\Omega)\times L^2(\Omega)$</span>, where</p><div>\[\begin{aligned}
a((v,q),(u,p)) &amp;\doteq \int_{\Omega}  v \cdot \left(\kappa^{-1} u\right) \ {\rm d}\Omega - \int_{\Omega} (\nabla \cdot v)\ p \ {\rm d}\Omega + \int_{\Omega} q\ (\nabla \cdot u) \ {\rm d}\Omega,\\
b(v,q) &amp;\doteq \int_{\Omega} q\ f \ {\rm  d}\Omega - \int_{\Gamma_{\rm N}} (v\cdot n)\ h  \ {\rm  d}\Gamma.
\end{aligned}\]</div><h2><a class="nav-anchor" id="Numerical-scheme-1" href="#Numerical-scheme-1">Numerical scheme</a></h2><p>In this tutorial, we use the Raviart-Thomas (RT)  space for the flux approximation [1]. On a reference square with sides aligned with the Cartesian axes, the RT space of order <span>$k$</span> is represented as <span>$Q_{(k,k-1)} \times Q_{(k-1,k)}$</span>, being the polynomial space defined as follows. The component <span>$\alpha$</span> of a vector field in <span>$Q_{(k,k-1)} \times Q_{(k-1,k)}$</span> is obtained as the tensor product of univariate polynomials of order <span>$k$</span> in direction <span>$\alpha$</span> times univariate polynomials of order <span>$k-1$</span> on the other directions. Note that this definition applies to arbitrary dimensions. The global FE space for the flux <span>$V$</span> is obtained by mapping the cell-wise RT space into the physical space using the Piola transformation and enforcing continuity of normal traces across cells (see [1] for specific details).</p><p>We consider the subspace  <span>$V_0$</span> of functions in <span>$V$</span> with zero normal trace on <span>$\Gamma_{\rm D}$</span>, and the subspace <span>$V_g$</span> of functions in <span>$V$</span> with normal trace equal to the projection of <span>$g$</span> onto the space of traces of <span>$V$</span> on <span>$\Gamma_{\rm D}$</span>. With regard to the pressure, we consider the discontinuous space of cell-wise polynomials in <span>$Q_{k-1}$</span>, i.e., multivariate polynomials of degree at most <span>$k-1$</span> in each of the spatial coordinates.</p><h2><a class="nav-anchor" id="Discrete-model-1" href="#Discrete-model-1">Discrete model</a></h2><p>We start the driver loading the Gridap package and constructing the geometrical model. We generate a <span>$100\times100$</span> structured mesh for the domain <span>$(0,1)^2$</span>.</p><pre><code class="language-julia">using Gridap
model = CartesianDiscreteModel(domain=(0.0,1.0,0.0,1.0), partition=(100,100))</code></pre><h2><a class="nav-anchor" id="Multi-field-FE-spaces-1" href="#Multi-field-FE-spaces-1">Multi-field FE spaces</a></h2><p>Next, we build the FE spaces. We consider the second order RT space for the flux and the discontinuous pressure space as described above.  This mixed FE pair satisfies the inf-sup condition and, thus, it is stable.</p><pre><code class="language-julia">order = 2

fespace1 = FESpace(
  reffe=:RaviartThomas, order=order, valuetype=VectorValue{2,Float64},
  conformity=:HDiv, model=model, diritags=[5,6])

fespace2 = FESpace(
  reffe=:QLagrangian, order=order-1, valuetype=Float64,
  conformity=:L2, model=model)</code></pre><p>Note that the Dirichlet boundary for the flux are the bottom and top sides of the squared domain (identified with the boundary tags 5, and 6 respectively), whereas no Dirichlet data can be imposed on the pressure space. We select <code>conformity=:HDiv</code> for the flux (i.e., shape functions with <span>$H^1(\mathrm{div};\Omega)$</span> regularity) and <code>conformity=:L2</code> for the pressure (i.e. discontinuous shape functions).</p><p>From these objects, we construct the test and trial spaces. Note that we impose homogeneous boundary conditions for the flux.</p><pre><code class="language-julia">uD(x) = VectorValue(0.0,0.0)
V = TestFESpace(fespace1)
U = TrialFESpace(fespace1,uD)
Q = TestFESpace(fespace2)
P = TrialFESpace(fespace2)</code></pre><p>When the singe-field spaces have been designed, the multi-field test and trial spaces are expressed as arrays of single-field ones in a natural way.</p><pre><code class="language-julia">Y = [V, Q]
X = [U, P]</code></pre><h2><a class="nav-anchor" id="Numerical-integration-1" href="#Numerical-integration-1">Numerical integration</a></h2><p>In this example we need to integrate in the interior of <span>$\Omega$</span> and on the Neumann boundary <span>$\Gamma_{\rm N}$</span>. For the volume integrals, we extract the triangulation from the geometrical model and define the corresponding cell-wise quadrature of degree of exactness at least 2 as follows.</p><pre><code class="language-julia">trian = Triangulation(model)
quad = CellQuadrature(trian,degree=2)</code></pre><p>In order to integrate the Neumann boundary condition, we only need to build an integration mesh for the right side of the domain (which is the only part of <span>$\Gamma_{\rm N}$</span>, where the Neumann function <span>$h$</span> is different from zero). Within the model, the right side of <span>$\Omega$</span> is identified with the boundary tag 8. Using this identifier, we extract the corresponding surface triangulation and create a quadrature with the desired degree of exactness.</p><pre><code class="language-julia">neumanntags = [8,]
btrian = BoundaryTriangulation(model,neumanntags)
bquad = CellQuadrature(btrian,degree=order*2)</code></pre><h2><a class="nav-anchor" id="Weak-form-1" href="#Weak-form-1">Weak form</a></h2><p>We start by defining the permeability tensors commented above using the <code>@law</code> macro.</p><pre><code class="language-julia">const kinv1 = TensorValue(1.0,0.0,0.0,1.0)
const kinv2 = TensorValue(100.0,90.0,90.0,100.0)
@law function σ(x,u)
   if ((abs(x[1]-0.5) &lt;= 0.1) &amp;&amp; (abs(x[2]-0.5) &lt;= 0.1))
      return kinv2*u
   else
      return kinv1*u
   end
end</code></pre><p>With this definition, we can express the integrand of the bilinear form as follows.</p><pre><code class="language-julia">function a(y,x)
   v, q = y
   u, p = x
   inner(v,σ(u)) - inner(div(v),p) + inner(q,div(u))
end</code></pre><p>The arguments <code>y</code> and <code>x</code> of previous function represent a test and a trial function in the multi-field test and trial spaces <code>Y</code> and <code>X</code> respectively. In the first lines in the function definition, we unpack the single-field test and trial functions from the multi-field ones. E.g., <code>v</code> represents a test function for the flux and <code>q</code> for the pressure. These quantities can also be written as <code>y[1]</code> and <code>y[2]</code> respectively. From the single-field functions, we write the different terms of the bilinear form as we have done in previous tutorials.</p><p>In a similar way, we can define the forcing term related to the Neumann boundary condition.</p><pre><code class="language-julia">nb = NormalVector(btrian)
h(x) = -1.0
function b_ΓN(y)
  v, q = y
  inner(v*nb, h)
end</code></pre><h2><a class="nav-anchor" id="Multi-field-FE-problem-1" href="#Multi-field-FE-problem-1">Multi-field FE problem</a></h2><p>Finally, we can assemble the FE problem and solve it. Note that we build the <code>LinearFEOperator</code> object using the multi-field test and trial spaces <code>Y</code> and <code>X</code>.</p><pre><code class="language-julia">t_Ω = LinearFETerm(a,trian,quad)
t_ΓN = FESource(b_ΓN,btrian,bquad)
op = LinearFEOperator(Y,X,t_Ω,t_ΓN)
xh = solve(op)
uh, ph = xh</code></pre><p>Since this is a multi-field example, the <code>solve</code> function returns a multi-field solution <code>xh</code>, which can be unpacked in order to finally recover each field of the problem. The resulting single-field objects can be visualized as in previous tutorials (see next figure).</p><pre><code class="language-julia">writevtk(trian,&quot;darcyresults&quot;,cellfields=[&quot;uh&quot;=&gt;uh,&quot;ph&quot;=&gt;ph])</code></pre><p><img src="../../assets/t007_darcy/darcy_results.png" alt/></p><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><p>[1] F. Brezzi and M. Fortin. <em>Mixed and hybrid finite element methods</em>. Springer-Verlag, 1991.</p><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../t005_dg_discretization/"><span class="direction">Previous</span><span class="title">6 Poisson equation (with DG)</span></a></footer></article></body></html>
