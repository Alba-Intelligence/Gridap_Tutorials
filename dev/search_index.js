var documenterSearchIndex = {"docs":
[{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/t004_hyperelasticity.jl\"","category":"page"},{"location":"pages/t004_hyperelasticity/#Tutorial-5:-Hyperelasticity-1","page":"5 Hyper-elasticity","title":"Tutorial 5: Hyperelasticity","text":"","category":"section"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t004_hyperelasticity/#Problem-statement-1","page":"5 Hyper-elasticity","title":"Problem statement","text":"","category":"section"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"using Gridap\nusing LinearAlgebra: inv, det\nusing LineSearches: BackTracking","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Material parameters","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"const λ = 100.0\nconst μ = 1.0","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Deformation Gradient","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"F(∇u) = one(∇u) + ∇u'\n\nJ(F) = sqrt(det(C(F)))\n\n#Green strain\n\n#E(F) = 0.5*( F'*F - one(F) )\n\n@law dE(x,∇du,∇u) = 0.5*( ∇du*F(∇u) + (∇du*F(∇u))' )","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Right Cauchy-green deformation tensor","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"C(F) = (F')*F","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Constitutive law (Neo hookean)","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"@law function S(x,∇u)\n  Cinv = inv(C(F(∇u)))\n  μ*(one(∇u)-Cinv) + λ*log(J(F(∇u)))*Cinv\nend\n\n@law function dS(x,∇du,∇u)\n  Cinv = inv(C(F(∇u)))\n  _dE = dE(x,∇du,∇u)\n  λ*inner(Cinv,_dE)*Cinv + 2*(μ-λ*log(J(F(∇u))))*Cinv*_dE*(Cinv')\nend","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Cauchy stress tensor","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"@law σ(x,∇u) = (1.0/J(F(∇u)))*F(∇u)*S(x,∇u)*(F(∇u))'","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Weak form","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"res(u,v) = inner( dE(∇(v),∇(u)) , S(∇(u)) )\n\njac_mat(u,v,du) = inner( dE(∇(v),∇(u)), dS(∇(du),∇(u)) )\n\njac_geo(u,v,du) = inner( ∇(v), S(∇(u))*∇(du) )\n\njac(u,v,du) = jac_mat(u,v,du) + jac_geo(u,v,du)","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Model","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"model = CartesianDiscreteModel(domain=(0.0,1.0,0.0,1.0), partition=(20,20))","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Define new boundaries","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"labels = FaceLabels(model)\nadd_tag_from_tags!(labels,\"diri_0\",[1,3,7])\nadd_tag_from_tags!(labels,\"diri_1\",[2,4,8])","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Construct the FEspace","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"order = 1\ndiritags = [\"diri_0\", \"diri_1\"]\nT = VectorValue{2,Float64}\nfespace = CLagrangianFESpace(T,model,labels,order,diritags)\nV = TestFESpace(fespace)","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Setup integration","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"trian = Triangulation(model)\nquad = CellQuadrature(trian,degree=2)","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Setup weak form terms","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"t_Ω = NonLinearFETerm(res,jac,trian,quad)","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Setup non-linear solver","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"nls = NLSolver(\n  show_trace=true,\n  method=:newton,\n  linesearch=BackTracking())\n\nsolver = NonLinearFESolver(nls)\n\n\nfunction run(x0,disp_x,step,nsteps)\n\n  g0 = zero(T)\n  g1 = VectorValue(disp_x,0.0)\n  U = TrialFESpace(fespace,[g0,g1])\n\n  #FE problem\n  op = NonLinearFEOperator(V,U,t_Ω)\n\n  println(\"\\n+++ Solving for disp_x $disp_x in step $step of $nsteps +++\\n\")\n\n  uh = FEFunction(U,x0)\n\n  solve!(uh,solver,op)\n\n  writevtk(trian,\"results_$(lpad(step,3,'0'))\",cellfields=[\"uh\"=>uh,\"sigma\"=>σ(∇(uh))])\n\n  return free_dofs(uh)\n\nend\n\nfunction runs()\n\n disp_max = 0.75\n disp_inc = 0.02\n nsteps = ceil(Int,abs(disp_max)/disp_inc)\n\n x0 = zeros(Float64,num_free_dofs(fespace))\n\n for step in 1:nsteps\n   disp_x = step * disp_max / nsteps\n   x0 = run(x0,disp_x,step,nsteps)\n end\n\nend\n\n#Do the work!\nruns()","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Picture of the last load step (Image: )","category":"page"},{"location":"pages/t004_hyperelasticity/#Extension-to-3D-1","page":"5 Hyper-elasticity","title":"Extension to 3D","text":"","category":"section"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Extending this tutorial to the 3D case is straightforward. It is leaved as an exercise.","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"(Image: )","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/t002_validation.jl\"","category":"page"},{"location":"pages/t002_validation/#Tutorial-2:-Code-validation-1","page":"2 Code validation","title":"Tutorial 2: Code validation","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In this tutorial, we will learn","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"How to implement the method of manufactured solutions\nHow to perform a convergence test\nHow to define the discretization error\nHow to integrate error norms\nHow to generate Cartesian meshes in arbitrary dimensions","category":"page"},{"location":"pages/t002_validation/#Problem-statement-1","page":"2 Code validation","title":"Problem statement","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In this tutorial, we show how to validate a code using the well known method of manufactured solutions. For the sake of simplicity, we consider the Poisson equation in the unit square Omegadoteq (01)^2 as a model problem,","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton partialOmega\nendaligned\nright","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We are going to consider two different manufactured solutions. On the one hand, we consider function u(x)=x_1+x_2, which can be exactly represented by the FE interpolation that we construct below. Thus, one expects that the obtained approximation error is near the machine precision. We are going to check that this is true in the code. On the other hand, we consider a function that cannot be captured exactly by the interpolation, namely u(x)=x_2 sin(2 pi x_1). Here, our goal is to confirm that the convergence order of the discretization error is the optimal one.","category":"page"},{"location":"pages/t002_validation/#Manufactured-solution-1","page":"2 Code validation","title":"Manufactured solution","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We start by defining the manufactured solution u(x) = x_1+x_2 and the source term f associated with it, namely fdoteq-Delta(x_1+x_2)=0.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"using Gridap\n\nu(x) = x[1] + x[2]\nf(x) = 0.0","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Note that it is important that function f returns a Float64 value. This is needed since we are going to use Float64 numbers to represent the solution.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We also need to define the gradient of u since we will compute the H^1 error norm later. In that case, the gradient is simply defined as","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"∇u(x) = VectorValue(1.0,1.0)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Note that we have used the constructor VectorValue to build the vector that represents the gradient. However, we still need a final trick. We need to tell the Gridap library that the gradient of the function u is available in the function ∇u (at this moment u and ∇u are two standard Julia functions without any connection between them). This is done by adding an extra method to the function gradient (aka ∇) defined in Gridap:","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"import Gridap: ∇\n∇(::typeof(u)) = ∇u","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Now, it is possible to recover function ∇u from function u as ∇(u). You can check that the following expression evaluates to true.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"∇(u) === ∇u","category":"page"},{"location":"pages/t002_validation/#Cartesian-mesh-generation-1","page":"2 Code validation","title":"Cartesian mesh generation","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In order to discretize the geometry of the unit square, we use the Cartesian mesh generator available in Gridap:","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"limits = (0.0, 1.0, 0.0, 1.0)\nmodel = CartesianDiscreteModel(domain=limits, partition=(4,4));","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The type CartesianDiscreteModel is a concrete type that inherits from DiscreteModel, which is specifically designed for building Cartesian meshes. The CartesianDiscreteModel constructor takes a tuple containing limits of the box we want to discretize  plus a tuple with the number of cells to be generated in each direction (here 4 by 4 cells). Note that the CaresianDiscreteModel is implemented for arbitrary dimensions. For instance, the following lines build a CartesianDiscreteModel  for the unit cube (01)^3 with 4 cells per direction","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"limits3d = (0.0, 1.0, 0.0, 1.0, 0.0, 1.0)\nmodel3d = CartesianDiscreteModel(domain=limits3d, partition=(4,4,4));","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"You could also generate a mesh for the unit tesseract (01)^4 (i.e., the unit cube in 4D). Look how the 2D and 3D models are build and just follow the sequence.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Let us return to the 2D CartesianDiscreteModel that we have already constructed. You can inspect it by writing it into vtk format. Note that you can also print a 3D model, but not a 4D one. In the future, it would be cool to generate a movie from a 4D model, but this functionality is not yet implemented.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"writevtk(model,\"model\");","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"If you open the generated files, you will see that the boundary vertices and facets are identified with the name \"boundary\". This is just what we need to impose the Dirichlet boundary conditions in this example.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"These are the vertices in the model","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"(Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"and these the facets","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"(Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"As you can see in the pictures, the objects on the boundary are correctly tagged with the name \"boundary\".","category":"page"},{"location":"pages/t002_validation/#FE-approximation-1","page":"2 Code validation","title":"FE approximation","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We compute a FE approximation of the Poisson problem above by following the steps detailed in the previous tutorial:","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"order = 1\nV = FESpace(\n  reffe=:Lagrangian, order=order, valuetype=Float64,\n  conformity=:H1, model=model, diritags=\"boundary\")\n\nV0 = TestFESpace(V)\nU = TrialFESpace(V,u)\n\ntrian = Triangulation(model)\nquad = CellQuadrature(trian,degree=2)\n\na(v,u) = inner(∇(v), ∇(u))\nb(v) = inner(v,f)\n\nt_Ω = AffineFETerm(a,b,trian,quad)\nop = LinearFEOperator(V0,U,t_Ω)\n\nuh = solve(op);","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Note that we are imposing Dirichlet boundary conditions on the objects tagged as \"boundary\" and that we are using the manufactured solution u to construct the trial FE space. Not also that we are not explicitly constructing an Assembler object nor a FESolver. We are relying on default values.","category":"page"},{"location":"pages/t002_validation/#Measuring-the-discretization-error-1","page":"2 Code validation","title":"Measuring the discretization error","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Our goal is to check that the discratization error associated with the computed approximation uh is close to machine precision. To this end, the first step is to compute the discretization error, which is done as you would expect:","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"e = u - uh;","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Once the error is defined, you can, e.g., visualize it.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"writevtk(trian,\"error\",cellfields=[\"e\" => e]);","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"This generates a file called error.vtu. Open it with Paraview to check that the error is of the order of the machine precision.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"(Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"A more rigorous way of quantifying the error is to measure it with a norm. Here, we use the L^2 and H^1 norms, which are defined as","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":" w _L^2^2 doteq int_Omega w^2  textdOmega quad\n w _H^1^2 doteq int_Omega w^2 + nabla w cdot nabla w  textdOmega","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In order to compute these norms, we are going to use the integrate function. To this end, we need to define the integrands that we want to integrate, namely","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"l2(w) = inner(w,w)\nh1(w) = a(w,w) + l2(w)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Note that in order to define the integrand of the H^1 norm, we have reused function a, previously used to define the bilinear form of the problem.  Once we have defined the integrands, we are ready to compute the integrals. For the L^2 norm","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"el2 = sqrt(sum( integrate(l2(e),trian,quad) ))","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"and for the H^1 norm","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"eh1 = sqrt(sum( integrate(h1(e),trian,quad) ))","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The integrate function works as follows. In the first argument, we pass the integrand. In the second and third arguments, we pass a Triangulation object and aCellQuadrature that represent the data needed in order to perform the integrals numerically. The integrate function returns an object containing the contribution to the integrated value of each cell in the given Triangulation. To end up with the desired error norms, one has to sum these contributions and take the square root. You can check that the computed error norms are close to machine precision (as one would expect).","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"tol = 1.e-10\n@assert el2 < tol\n@assert eh1 < tol","category":"page"},{"location":"pages/t002_validation/#Convergence-test-1","page":"2 Code validation","title":"Convergence test","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We end up this tutorial by performing a convergence test, where we are going to use all the new concepts we have learned.  We will consider a manufactured solution that does not belong to the FE interpolation space. In this test, we expect to see the optimal convergence order of the FE discretization.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Here, we define the manufactured functions","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"const k = 2*pi\nu(x) = sin(k*x[1]) * x[2]\n∇u(x) = VectorValue(k*cos(k*x[1])*x[2], sin(k*x[1]))\nf(x) = (k^2)*sin(k*x[1])*x[2]","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Since we have redefined the valiables u, ∇u, and f, we need to execute these lines again","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"∇(::typeof(u)) = ∇u\nb(v) = inner(v,f)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In order to perform the convergence test, we write in a function all the code needed to perform a single computation and measure its error. The input of this function is the number of cells in each direction and the interpolation order. The output is the computed L^2 and H^1 error norms.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"function run(n,order)\n\n  limits = (0.0, 1.0, 0.0, 1.0)\n  model = CartesianDiscreteModel(domain=limits, partition=(n,n))\n\n  V = FESpace(\n    reffe=:Lagrangian, order=order, valuetype=Float64,\n    conformity=:H1, model=model, diritags=\"boundary\")\n\n  V0 = TestFESpace(V)\n  U = TrialFESpace(V,u)\n\n  trian = Triangulation(model)\n  quad = CellQuadrature(trian,degree=order+2)\n\n  t_Ω = AffineFETerm(a,b,trian,quad)\n  op = LinearFEOperator(V0,U,t_Ω)\n\n  uh = solve(op)\n\n  e = u - uh\n\n  el2 = sqrt(sum( integrate(l2(e),trian,quad) ))\n  eh1 = sqrt(sum( integrate(h1(e),trian,quad) ))\n\n  (el2, eh1)\n\nend","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The following function does the convergence test. It takes a vector of integers (representing the number of cells per direction in each computation) plus the interpolation order. It returns the L^2 and H^1 error norms for each computation as well as the corresponding cell size.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"function conv_test(ns,order)\n\n  el2s = Float64[]\n  eh1s = Float64[]\n  hs = Float64[]\n\n  for n in ns\n\n    el2, eh1 = run(n,order)\n    h = 1.0/n\n\n    push!(el2s,el2)\n    push!(eh1s,eh1)\n    push!(hs,h)\n\n  end\n\n  (el2s, eh1s, hs)\n\nend","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We are ready to perform the test! We consider several mesh sizes and interpolation order equal to 2.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"el2s, eh1s, hs = conv_test([8,16,32,64,128],2);","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"With the generated data, we do the classical convergence plot.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"using Plots\n\nplot(hs,[el2s eh1s],\n    xaxis=:log, yaxis=:log,\n    label=[\"L2\" \"H1\"],\n    shape=:auto,\n    xlabel=\"h\",ylabel=\"error norm\")","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"If you run the code in a notebook, you will see a figure like this one: (Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The generated curves make sense. It is observed that the convergence of the H^1 error is slower that L^2 one. However, in order to be more conclusive, we need to compute the slope of these lines. It can be done with this little function that internally uses a linear regression.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"function slope(hs,errors)\n  x = log10.(hs)\n  y = log10.(errors)\n  linreg = hcat(fill!(similar(x), 1), x) \\ y\n  linreg[2]\nend","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The slope for the L^2 error norm is computed as","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"slope(hs,el2s)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"and for the H^1 error norm","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"slope(hs,eh1s)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"If your run these lines in a notebook, you will see that the slopes for the L^2 and H^1 error norms are circa 3 and 2 respectively (as one expects for interpolation order 2)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Congrats, another tutorial done!","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/t001_poisson.jl\"","category":"page"},{"location":"pages/t001_poisson/#Tutorial-1:-Poisson-equation-1","page":"1 Poisson equation","title":"Tutorial 1: Poisson equation","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In this tutorial, we will learn","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"How to solve a simple PDE in Julia with Gridap\nHow to load a discrete model (aka a FE mesh) from a file\nHow to build a conforming Lagrangian FE space\nHow to define the different terms in a weak form\nHow to impose Dirichlet and Neumann boundary conditions\nHow to visualize results","category":"page"},{"location":"pages/t001_poisson/#Problem-statement-1","page":"1 Poisson equation","title":"Problem statement","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In this first tutorial, we provide an overview of a complete simulation pipeline in Gridap: from the construction of the FE mesh to the visualization of the computed results. To this end, we consider a simple model problem: the Poisson equation.  We want to solve the Poisson equation on the 3D domain depicted in next figure with Dirichlet and Neumann boundary conditions. Dirichlet boundary conditions are applied on Gamma_rm D, being the outer sides of the prism (marked in red). Non-homogeneous Neumann conditions are applied to the internal boundaries Gamma_rm G, Gamma_rm Y, and Gamma_rm B (marked in green, yellow and blue respectively). And homogeneous Neumann boundary conditions are applied in Gamma_rm W, the remaining portion of the boundary (marked in white).","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: )","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Formally, the problem to solve is: find the scalar field u such that","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton Gamma_rm D\nnabla ucdot n = h  texton  Gamma_rm N\nendaligned\nright","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"being n the outwards unit normal vector to the Neumann boundary Gamma_rm N doteq Gamma_rm GcupGamma_rm YcupGamma_rm BcupGamma_rm W. In this example, we chose f(x) = 1, g(x) = 2, and h(x)=3 on Gamma_rm GcupGamma_rm YcupGamma_rm B and h(x)=0 on Gamma_rm W. The variable x is the position vector x=(x_1x_2x_3).","category":"page"},{"location":"pages/t001_poisson/#Numerical-scheme-1","page":"1 Poisson equation","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"To solve this PDE, we use a conventional Galerkin finite element (FE) method with conforming Lagrangian FE spaces (see, e.g., [1] for specific details on this formulation). The weak form associated with this formulation is: find uin U_g such that $ a(v,u) = b(v) $ for all vin V_0, where U_g and V_0 are the subset of functions in H^1(Omega) that fulfill the Dirichlet boundary condition g and 0 respectively. The bilinear and linear forms for this problems are","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"  a(vu) doteq int_Omega nabla v cdot nabla u  rm dOmega quad b(v) doteq int_Omega v f   rm  dOmega + int_Gamma_rm N v h  rm dGamma_rm N","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The problem is solved numerically by approximating the spaces U_g and V_0 by their discrete counterparts associated with a FE mesh of the computational domain Omega. As we have anticipated, we consider standard conforming Lagrangian FE spaces for this purpose.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The implementation of this numerical scheme in Gridap is done in a user-friendly way thanks to the abstractions provided by the library. As it will be seen below, all the mathematical objects involved in the definition of the discrete weak problem have a correspondent representation in the code.","category":"page"},{"location":"pages/t001_poisson/#Setup-1","page":"1 Poisson equation","title":"Setup","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The step number 0 in order to solve the problem is to load the Gridap library in the code. If you have configured your Julia environment properly (see \\sect{sec:installing_gridap}), it is simply done with the line:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"using Gridap","category":"page"},{"location":"pages/t001_poisson/#Discrete-model-1","page":"1 Poisson equation","title":"Discrete model","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"As in any FE simulation, we need a discretization of the computational domain (i.e., a FE mesh). All geometrical data needed for solving a FE problem is provided in Gridap by types inheriting from the abstract type DiscreteModel. In the following line, we build an instance of DiscreteModel by loading a json file.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"model = DiscreteModelFromFile(\"../models/model.json\")","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The file \"model.json\" is a regular json file that includes a set of fields that describe the discrete model. It was generated by using together the GMSH mesh generator and the GridapGmsh package. First, we generate a \"model.msh\" file with GMSH (which contains a FE mesh and information about user-defined physical boundaries in {GMSH} format). Then, this file is converted to the Gridap-compatible \"model.json\" file using the conversion tools available in the GridapGmsh package. See the documentation of the GridapGmsh for more information.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"You can easily inspect the generated discrete model in Paraview by writing it in vtk format.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"writevtk(model,\"model\")","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The previous line generates four different files model_0.vtu, model_1.vtu, model_2.vtu, and model_3.vtu containing the vertices, edges, faces, and cells present in the discrete model. Moreover, you can easily inspect which boundaries are defined within the model.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"For instance, if you want to see which faces of the model are on the boundary Gamma_rm B (i.e., the walls of the circular perforation), open the file model_2.vtu and chose coloring by the element field \"circle\". You should see that only the faces on the circular hole have a value different from zero (see next figure).","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: )","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"It is also possible to see which vertices are on the Dirichlet boundary Gamma_rm D. To do so, open the file model_0.vtu and chose coloring by the field \"sides\" (see next figure).","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: )","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"That is, the boundary Gamma_rm B (i.e., the walls of the circular hole) is called \"circle\" and the Dirichlet boundary Gamma_rm D is called \"sides\" in the model. In addition, the walls of the triangular hole Gamma_rm G and the walls of the square hole Gamma_rm Y are identified in the model with the names \"triangle\" and \"square\" respectively. You can easily check this by opening the corresponding file in Paraview.","category":"page"},{"location":"pages/t001_poisson/#FE-spaces-1","page":"1 Poisson equation","title":"FE spaces","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Once we have a discretization of the computational domain, the next step is to generate a discrete approximation of the finite element spaces V_0 and U_g (i.e. the test and trial FE spaces) of the problem. To do so, first, we are going to build a discretization of Vdoteq H^1(Omega) as the standard Conforming Lagrangian FE space (without boundary conditions) associated with the discretization of the computational domain. The approximation of the FE space V is build as follows:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"V = FESpace(\n  reffe=:Lagrangian, order=1, valuetype=Float64,\n  conformity=:H1, model=model, diritags=\"sides\")","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Here, we have used the FESpace constructor, which constructs a particular FE space from a set of options described as key-word arguments. The with the options reffe=:Lagrangian, order=1, and  valuetype=Float64, we define the local interpolation at the reference FE element. In this case, we select a scalar-valued, first order, Lagrangian interpolation. In particular, the value of the shape functions will be represented with  64-bit floating point numbers. With the key-word argument conformity we define the regularity of the interpolation at the boundaries of the cells in the mesh. Here, we use conformity=:H1, which means that the resulting interpolation space is a subset of H^1(Omega) (i.e., continuous shape functions). On the other hand, with the key-word argument model, we select the discrete model on top of which we want to construct the FE space. Finally, we pass the identifiers of the Dirichlet boundary via the diritags argument. In this case, we mark as Dirichlet all objects of the discrete model identified with the \"sides\" tag. Note that, even though functions in V are not constrained by Dirichlet boundary conditions, the underlying implementation is aware of which functions have support on the Dirichlet boundary. This is why we need to pass the argument diritags.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Once the space V is discretized in the code, we proceed with the approximation of the test and trial spaces V_0 and U_g.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"g(x) = 2.0\nV0 = TestFESpace(V)\nUg = TrialFESpace(V,g)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"To this end, we have used the TestFESpace and TrialFESpace constructors. Note that we have passed a function representing the value of the Dirichlet boundary condition, when building the trial space. This is not necessary for the test space, since functions in the test space are always constrained to 0 on the Dirichlet boundary.","category":"page"},{"location":"pages/t001_poisson/#Numerical-integration-1","page":"1 Poisson equation","title":"Numerical integration","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Once we have built the interpolation spaces, the next step is to set up the machinery to perform the integrals in the weak form numerically. Here, we need to compute integrals on the interior of the domain Omega and on the Neumann boundary Gamma_rm N. In both cases, we need two main ingredients. We need to define an integration mesh (i.e. a triangulation of the integration domain), plus a Gauss-like quadrature in each of the cells in the triangulation. In Gridap, integration meshes are represented by types inheriting from the abstract type Triangulation. For integrating on the domain Omega, we build the following triangulation and quadrature:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"trian = Triangulation(model)\nquad = CellQuadrature(trian,degree=2)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Here, we build a triangulation from the cells of the model and define a quadrature of degree  2 in the cells of this triangulation. This is enough for integrating the corresponding terms of the weak form exactly for an interpolation of order 1.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"On the other hand, we need a special type of triangulation, represented by the type\t BoundaryTriangulation, to integrate on the boundary. Essentially, a  BoundaryTriangulation is a particular type of Triangulation that is aware of which cells in the model are touched by faces on the boundary. We build an instance of this type from the discrete model and the names used to identify the Neumann boundary as follows:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"neumanntags = [\"circle\", \"triangle\", \"square\"]\nbtrian = BoundaryTriangulation(model,neumanntags)\nbquad = CellQuadrature(btrian,degree=2)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In addition, we have created a quadrature of degree 2 on top of the cells in the triangulation for the Neumann boundary.","category":"page"},{"location":"pages/t001_poisson/#Weak-form-1","page":"1 Poisson equation","title":"Weak form","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"With all the ingredients presented so far, we are ready to define the weak form. This is done by means of types inheriting from the abstract type FETerm. In this tutorial, we will use the sub-types AffineFETerm and FESource. An AffineFETerm is a term that contributes both to the system matrix and the right-hand-side vector, whereas a FESource only contributes to the right hand side vector. Here, we use an AffineFETerm to represent all the terms in the weak form that are integrated over the interior of the domain Omega.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"f(x) = 1.0\na(v,u) = inner( ∇(v), ∇(u) )\nb_Ω(v) = inner(v, f)\nt_Ω = AffineFETerm(a,b_Ω,trian,quad)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In the first argument of the AffineFETerm constructor, we pass a function that represents the integrand of the bilinear form a(cdotcdot). The second argument is a function that represents the integrand of the part of the linear form b(cdot) that is integrated over the domain Omega. The third argument is the Triangulation on which we want to perform the integration (in that case the integration mesh for Omega), and the last argument is the CellQuadrature needed to perform the integration numerically. Since the contribution of the Neumann boundary condition is integrated over a different domain, it cannot be included in the previous AffineFETerm. To account for it, we use a FESource:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"h(x) = 3.0\nb_Γ(v) = inner(v, h)\nt_Γ = FESource(b_Γ,btrian,bquad)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In the first argument of the FESource constructor, we pass a function representing the integrand of the Neumann boundary condition. In the two last arguments we pass the triangulation and quadrature for the Neumann boundary.","category":"page"},{"location":"pages/t001_poisson/#FE-Problem-1","page":"1 Poisson equation","title":"FE Problem","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"At this point, we can build the FE problem that, once solved, will provide the numerical solution we are looking for. A FE problem is represented in Gridap by types inheriting from the abstract type FEOperator (both for linear and nonlinear cases). Since we want to solve a linear problem, we use the concrete type LinearFEOperator.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"op = LinearFEOperator(V0,Ug,t_Ω,t_Γ)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Note that the LinearFEOperator object representing our FE problem is built from the test and trial FE spaces V0 and Ug, and the objects t_Ω and t_Γ representing the weak form.","category":"page"},{"location":"pages/t001_poisson/#Solver-phase-1","page":"1 Poisson equation","title":"Solver phase","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"We have constructed a FE problem, the last step is to solve it. In Gridap, FE problems are solved with types inheriting from the abstract type FESolver. Since this is a linear problem, we use a LinearFESolver:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"ls = LUSolver()\nsolver = LinearFESolver(ls)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"LinearFESolver objects are build from a given algebraic linear solver. In this case, we use a LU factorization. Now we are ready to solve the FE problem with the FE solver as follows:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"uh = solve(solver,op)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The solve function returns the computed numerical solution uh. This object is an instance of FEFunction, the type used to represent a function in a FE space. We can inspect the result by writing it into a vtk file:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"writevtk(trian,\"results\",cellfields=[\"uh\"=>uh])","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"which will generate a file named results.vtu having a nodal field named \"uh\" containing the solution of our problem (see next figure).","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: )","category":"page"},{"location":"pages/t001_poisson/#References-1","page":"1 Poisson equation","title":"References","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"[1] C. Johnson. Numerical Solution of Partial Differential Equations by the Finite Element Method. Dover Publications, 2009.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/t005_dg_discretization.jl\"","category":"page"},{"location":"pages/t005_dg_discretization/#Tutorial-6:-Poisson-equation-(with-DG)-1","page":"6 Poisson equation (with DG)","title":"Tutorial 6: Poisson equation (with DG)","text":"","category":"section"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t005_dg_discretization/#Learning-outcomes-1","page":"6 Poisson equation (with DG)","title":"Learning outcomes","text":"","category":"section"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"How to solve a simple with a Discontinuous Galerkin (DG) discretization\nHow to build discontinuous FE spaces\nHow to integrate quantities on the mesh skeleton\nHow to compute jumps and averages of quantities on the mesh skeleton","category":"page"},{"location":"pages/t005_dg_discretization/#Problem-statement-1","page":"6 Poisson equation (with DG)","title":"Problem statement","text":"","category":"section"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"The goal of this tutorial is to solve a simple PDE using a Discontinuous Galerkin (DG) formulation. For simplicity, we take the Poisson equation on the unit multi dimensional cube Omega doteq (01)^d, with d=2 and d=3, as a model problem:","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton partialOmega\nendaligned\nright","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"where f is the source term and g is the Dirichlet boundary value.","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"We are going to solve two version of this problem. In a first stage, we take d=3 and consider a manufactured solution, namely u(x) = 3 x_1 + x_2 + 2 x_3, that belongs to the FE interpolation that we will build below. In this case, we expect to compute a numerical solution with an approximation error close to the machine precision. On the other hand, we will perform a convergence test for the 2D case (d=2). To this, end we will consider a manufactured solution that cannot by represented exactly by the interpolation, namely u(x)=x_2 sin(2 pi x_1). Our goal is to confirm that the convergence order of the discretization error is the optimal one.","category":"page"},{"location":"pages/t005_dg_discretization/#Numerical-Scheme-1","page":"6 Poisson equation (with DG)","title":"Numerical Scheme","text":"","category":"section"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"In contrast to previous tutorials, we consider a DG formulation to approximate the problem. For the sake of simplicity, we take the well know (symmetric) interior penalty method. For this formulation, the approximation space is made of discontinuous piece-wise polynomials, namely","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"V doteq  vin L^2(Omega) v_Tin Q_p(T) text for all  TinmathcalT  ","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"where mathcalT is the set of all cells T of the FE mesh, and Q_p(T) is a polynomial space of degree p defined on a generic cell T. For simplicity, we consider Cartesian meshes in this tutorial. In this case, the space Q_p(T) is made of multi-variate polynomials up to degree p in each spatial coordinate.","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"In order to write the weak form of the problem, we need to introduce the set of interior and boundary facets associated with the FE mesh, denoted here as mathcalF_Gamma and mathcalF_partialOmega respectively. In addition, for a given function vin V restricted to the interior facets mathcalF_Gamma, we need to define the well known jump and mean value operators:","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"lbracklbrack v n rbrackrbrack doteq v^+ n^+ + v^- n^- text and   nabla v  doteq dfrac nabla v^+ + nabla v^-2","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"with v^+, and v^- being the restrictions of vin V to the cells T^+, T^- that share a generic interior facet in mathcalF_Gamma, and n^+, and n^- are the facet outward unit normals from either the perspective of T^+ and T^- respectively.","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"With this notation, the weak form associated with the interior penalty formulation reads: find uin V such that a(vu) = b(v) for all vin V. The bilinear a(cdotcdot) and linear form b(cdot) have contributions associated with the bulk of Omega, and the boundary and interior facets mathcalF_partialOmega, mathcalF_Gamma, namely","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"beginaligned\na(vu) = a_Omega(vu) + a_partialOmega(vu) + a_Gamma(vu)\nb(v) = b_Omega(v) + b_partialOmega(v)\nendaligned","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"which are defined as","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"a_Omega(vu) doteq sum_TinmathcalT int_T nabla v cdot nabla u  rm dT quad b_Omega(v) doteq int_Omega v f  rm dOmega","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"for the volume","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"beginaligned\na_partialOmega(vu) doteq sum_FinmathcalF_partialOmega dfracgammaF int_F v u  rm dF -  sum_FinmathcalF_partialOmega int_F v (nabla u cdot n)   rm dF -  sum_FinmathcalF_partialOmega int_F (nabla v cdot n) u   rm dF \nb_partialOmega doteq sum_FinmathcalF_partialOmega dfracgammaF int_F v g  rm dF  -  sum_FinmathcalF_partialOmega int_F (nabla v cdot n) g   rm dF\nendaligned","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"for the boundary facets and","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"a_Gamma(vu) doteq sum_FinmathcalF_Gamma dfracgammaF int_F lbracklbrack v n rbrackrbrackcdot lbracklbrack u n rbrackrbrack  rm dF -  sum_FinmathcalF_Gamma int_F lbracklbrack v n rbrackrbrackcdot  nabla u   rm dF -  sum_FinmathcalF_Gamma int_F  nabla v cdot lbracklbrack u n rbrackrbrack  rm dF","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"for the interior facets. In previous expressions, F denotes the diameter of the face F (in our Cartesian grid, this is equivalent to the characteristic mesh size h), and gamma is a stabilization parameter that should be chosen large enough such that the bilinear form a(cdotcdot) is stable and continuous. Here, we take gamma = p (p+1).","category":"page"},{"location":"pages/t005_dg_discretization/#D-manufactured-solution-1","page":"6 Poisson equation (with DG)","title":"3D manufactured solution","text":"","category":"section"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"using Gridap\nimport Gridap: ∇\n\nu(x) = 3*x[1] + x[2] + 2*x[3]\n∇u(x) = VectorValue(3.0,1.0,2.0)\n∇(::typeof(u)) = ∇u\nf(x) = 0.0\ng(x) = u(x)\n\nL = 1.0\nlimits = (0.0, L, 0.0, L, 0.0, L)\nn = 4\nmodel = CartesianDiscreteModel(domain=limits, partition=(n,n,n))\n\nh = L / n\n\norder = 3\n\nfespace = FESpace(\n  reffe=:Lagrangian,\n  conformity = :L2,\n  valuetype = Float64,\n  model = model,\n  order = order)\n\nγ = order*(order+1)\n\nV = TestFESpace(fespace)\nU = TrialFESpace(fespace)\n\ntrian = Triangulation(model)\nquad = CellQuadrature(trian,degree=2*order)\n\nbtrian = BoundaryTriangulation(model)\nbquad = CellQuadrature(btrian,degree=2*order)\n\nstrian = SkeletonTriangulation(model)\nsquad = CellQuadrature(strian,degree=2*order)","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"(Image: )","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"nb = NormalVector(btrian)\nns = NormalVector(strian)\n\nwritevtk(strian,\"strian\")\n\na_Ω(v,u) = inner(∇(v), ∇(u))\nb_Ω(v) = inner(v,f)\nt_Ω = AffineFETerm(a_Ω,b_Ω,trian,quad)\n\na_∂Ω(v,u) = (γ/h) * inner(v,u) - inner(v, ∇(u)*nb ) - inner(∇(v)*nb, u)\nb_∂Ω(v) = (γ/h) * inner(v,g) - inner(∇(v)*nb, g)\nt_∂Ω = AffineFETerm(a_∂Ω,b_∂Ω,btrian,bquad)\n\na_Γ(v,u) = (γ/h) * inner( jump(v*ns), jump(u*ns)) -\n  inner( jump(v*ns), mean(∇(u)) ) - inner( mean(∇(v)), jump(u*ns) )\nt_Γ = LinearFETerm(a_Γ,strian,squad)\n\nop = LinearFEOperator(V,U,t_Ω,t_∂Ω,t_Γ)\n\nuh = solve(op)\n\nuh_Γ = restrict(uh,strian)\n\nwritevtk(strian,\"jumps\",\n cellfields=[\"jump_u\"=>jump(uh_Γ), \"jump_gradn_u\"=> jump(∇(uh_Γ)*ns)])","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"(Image: )","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"e = u - uh\n\nwritevtk(trian,\"trian\",cellfields=[\"uh\"=>uh,\"e\"=>e])","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"(Image: )","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"l2(u) = inner(u,u)\nh1(u) = a_Ω(u,u) + l2(u)\n\nel2 = sqrt(sum( integrate(l2(e),trian,quad) ))\neh1 = sqrt(sum( integrate(h1(e),trian,quad) ))\n\n\nconst k = 2*pi\nu(x) = sin(k*x[1]) * x[2]\n∇u(x) = VectorValue(k*cos(k*x[1])*x[2], sin(k*x[1]))\nf(x) = (k^2)*sin(k*x[1])*x[2]\n∇(::typeof(u)) = ∇u\n\nfunction run(n,order)\n\n  #Setup model\n  L = 1.0\n  h = L / n\n  limits = (0.0, L, 0.0, L)\n  partition = (n,n)\n  model = CartesianDiscreteModel(domain=limits, partition=partition)\n\n  #Setup FE spaces\n  fespace = FESpace(\n    reffe=:Lagrangian,\n    conformity = :L2,\n    valuetype = Float64,\n    model = model,\n    order = order)\n  V = TestFESpace(fespace)\n  U = TrialFESpace(fespace)\n\n  #Setup integration meshes\n  trian = Triangulation(model)\n  btrian = BoundaryTriangulation(model)\n  strian = SkeletonTriangulation(model)\n\n  #Setup quadratures\n  quad = CellQuadrature(trian,degree=2*order)\n  squad = CellQuadrature(strian,degree=2*order)\n  bquad = CellQuadrature(btrian,degree=2*order)\n\n  #Setup normal vectors\n  nb = NormalVector(btrian)\n  ns = NormalVector(strian)\n\n  #Setup weak form (volume)\n  a_Ω(v,u) = inner(∇(v), ∇(u))\n  b_Ω(v) = inner(v,f)\n\n  #Setup weak form (boundary)\n  γ = order*(order+1)\n  a_∂Ω(v,u) = (γ/h) * inner(v,u) - inner(v, ∇(u)*nb ) - inner(∇(v)*nb, u)\n  b_∂Ω(v) = (γ/h) * inner(v,g) - inner(∇(v)*nb, g)\n\n  #Setup weak form (skeleton)\n  a_Γ(v,u) = (γ/h) * inner( jump(v*ns), jump(u*ns)) -\n    inner( jump(v*ns), mean(∇(u)) ) - inner( mean(∇(v)), jump(u*ns) )\n\n  #Setup FE problem\n  t_Ω = AffineFETerm(a_Ω,b_Ω,trian,quad)\n  t_Γ = LinearFETerm(a_Γ,strian,squad)\n  t_∂Ω = AffineFETerm(a_∂Ω,b_∂Ω,btrian,bquad)\n  op = LinearFEOperator(V,U,t_Ω,t_∂Ω,t_Γ)\n\n  #Solve\n  uh = solve(op)\n\n  #Measure discretization error\n  e = u - uh\n  l2(u) = inner(u,u)\n  h1(u) = a_Ω(u,u) + l2(u)\n  el2 = sqrt(sum( integrate(l2(e),trian,quad) ))\n  eh1 = sqrt(sum( integrate(h1(e),trian,quad) ))\n\n  (el2, eh1, h)\n\nend\n\nfunction conv_test(ns,order)\n\n  el2s = Float64[]\n  eh1s = Float64[]\n  hs = Float64[]\n\n  for n in ns\n    @show n\n    el2, eh1, h = run(n,order)\n    push!(el2s,el2)\n    push!(eh1s,eh1)\n    push!(hs,h)\n  end\n\n  (el2s, eh1s, hs)\n\nend\n\n\nel2s, eh1s, hs = conv_test([8,16,32,64],3)\n\nusing Plots\n\nplot(hs,[el2s eh1s],\n    xaxis=:log, yaxis=:log,\n    label=[\"L2\" \"H1\"],\n    shape=:auto,\n    xlabel=\"h\",ylabel=\"error norm\")\n\n\nfunction slope(hs,errors)\n  x = log10.(hs)\n  y = log10.(errors)\n  linreg = hcat(fill!(similar(x), 1), x) \\ y\n  linreg[2]\nend\n\nslope(hs,el2s)\n\nslope(hs,eh1s)","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"(Image: )","category":"page"},{"location":"pages/t005_dg_discretization/#","page":"6 Poisson equation (with DG)","title":"6 Poisson equation (with DG)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/t003_elasticity.jl\"","category":"page"},{"location":"pages/t003_elasticity/#Tutorial-3:-Linear-elasticity-1","page":"3 Linear elasticity","title":"Tutorial 3: Linear elasticity","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"In this tutorial, we will learn","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"How to approximate vector-valued problems\nHow to solve problems with complex constitutive laws\nHow to impose Dirichlet boundary conditions only in selected components\nHow to impose Dirichlet boundary conditions described by more than one function","category":"page"},{"location":"pages/t003_elasticity/#Problem-statement-1","page":"3 Linear elasticity","title":"Problem statement","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"In this tutorial, we detail how to solve a linear elasticity problem defined on the 3D domain depicted in next figure.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"(Image: )","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"We impose the following boundary conditions. All components of the displacement vector  are constrained to zero on the surface Gamma_rm G, which is marked in green in the figure. On the other hand, the first component of the displacement vector is prescribed to the value deltadoteq 5mm on the surface Gamma_rm B, which is marked in blue. No body or surface forces are included in this example. Formally, the PDE to solve is","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"leftlbrace\nbeginaligned\n-cdotsigma(u) = 0  textin  Omega\nu = 0  texton Gamma_rm G\nu_1 = delta  texton Gamma_rm B\nsigma(u)cdot n = 0  texton  Gamma_rm N\nendaligned\nright","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The variable u stands for the unknown displacement vector, the vector n is the unit outward normal to the Neumann boundary Gamma_rm NdoteqpartialOmegasetminusleft(Gamma_rm BcupGamma_rm Gright) and sigma(u) is the stress tensor defined as","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"sigma(u) doteq lambda rm tr(varepsilon(u))  I +2 mu   varepsilon(u)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"where I is the 2nd order identity tensor, and lambda and mu are the Lamé parameters of the material. The operator varepsilon(u)doteqfrac12left(nabla u + (nabla u)^t right) is the symmetric gradient operator (i.e., the strain tensor). Here, we consider material parameters corresponding to aluminum with Young's modulus E=70cdot 10^9 Pa and Poisson's ratio nu=033. From these values, the Lamé parameters are obtained as lambda = (Enu)((1+nu)(1-2nu)) and mu=E(2(1+nu)).","category":"page"},{"location":"pages/t003_elasticity/#Numerical-scheme-1","page":"3 Linear elasticity","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"As in previous tutorial, we use a conventional Galerkin FE method with conforming Lagrangian FE spaces. For this formulation, the weak form is: find uin U such that $ a(v,u) = 0 $ for all vin V_0, where U is the subset of functions in VdoteqH^1(Omega)^3 that fulfill the Dirichlet boundary conditions of the problem, whereas V_0 are functions in V fulfilling v=0 on Gamma_rm G and v_1=0 on Gamma_rm B. The bilinear form of the problem is","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"a(vu)doteq int_Omega varepsilon(v)  sigma(u)  rm dOmega","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The main differences with respect to previous tutorial is that we need to deal with a vector-valued problem, we need to impose different prescribed values on the Dirichlet boundary, and the integrand of the bilinear form a(cdotcdot) is more complex as it involves the symmetric gradient operator and the stress tensor. However, the implementation of this numerical scheme is still done in a user-friendly way since all these features can be easily accounted for with the abstractions in the library.","category":"page"},{"location":"pages/t003_elasticity/#Discrete-model-1","page":"3 Linear elasticity","title":"Discrete model","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"We start by loading the discrete model from a file","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"using Gridap\nmodel = DiscreteModelFromFile(\"../models/solid.json\")","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"In order to inspect it, write the model to vtk","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"writevtk(model,\"model\")","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"and open the resulting files with Paraview. The boundaries Gamma_rm B and Gamma_rm G are identified  with the names \"surface_1\" and \"surface_2\" respectively.  For instance, if you visualize the faces of the model and color them by the field \"surface_2\" (see next figure), you will see that only the faces on Gamma_rm G have a value different from zero.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"(Image: )","category":"page"},{"location":"pages/t003_elasticity/#Vector-valued-FE-space-1","page":"3 Linear elasticity","title":"Vector-valued FE space","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The next step is the construction of the FE space. Here, we need to build a vector-valued FE space, which is done as follows:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"order = 1\n\nV = FESpace(\n  reffe=:Lagrangian, order=1, valuetype=VectorValue{3,Float64},\n  conformity=:H1, model=model, diritags=[\"surface_1\",\"surface_2\"],\n  dirimasks=[(true,false,false), (true,true,true)])","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"As in previous tutorial, we construct a continuous Lagrangian interpolation of order 1. The vector-valued interpolation is selected via the option valuetype=VectorValue{3,Float64}, where we use the type VectorValue{3,Float64}, which is the way Gridap represents vectors of three Float64 components. We mark as Dirichlet the objects identified with the tags \"surface_1\" and \"surface_2\" using the diritags argument. Finally, we chose which components of the displacement are actually constrained on the Dirichlet boundary via the dirimasks argument. Note that we constrain only the first component on the boundary Gamma_rm B (identified as \"surface_1\"), whereas we constrain all components on Gamma_rm G (identified as \"surface_2\").","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The test space is built as in previous tutorial.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"V0 = TestFESpace(V)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"However, the construction of the trial space is slightly different in this case. The Dirichlet boundary conditions are described with two different functions, one for boundary Gamma_rm B and another one for Gamma_rm G. These functions can be defined as","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"g1(x) = VectorValue(0.005,0.0,0.0)\ng2(x) = VectorValue(0.0,0.0,0.0)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"From functions g1 and g2, we define the trial space as follows:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"U = TrialFESpace(V,[g1,g2])","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Note that the functions g1 and g2 are passed to the TrialFESpace constructor in the same order as the boundary identifiers are passed previously in the diritags argument of the FESpace constructor.","category":"page"},{"location":"pages/t003_elasticity/#Constitutive-law-1","page":"3 Linear elasticity","title":"Constitutive law","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Once the FE spaces are defined, the next step is to define the weak form.  In this example, the construction of the weak form requires more work than in previous tutorial since we need to account for the constitutive law that relates strain and stress. In this case, the integrand of the bilinear form of the problem is written in the code as follows:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"a(v,u) = inner( ε(v), σ(ε(u)) )","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The symmetric gradient operator is represented by the function ε provided by Gridap (also available as symmetric_gradient). However, function σ representing the stress tensor is not predefined in the library and it has to be defined ad-hoc by the user. The way function σ and other types of constitutive laws are defined  in Gridap is by using the supplied macro @law:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"const E = 70.0e9\nconst ν = 0.33\nconst λ = (E*ν)/((1+ν)*(1-2*ν))\nconst μ = E/(2*(1+ν))\n@law σ(x,ε) = λ*tr(ε)*one(ε) + 2*μ*ε","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The macro @law is placed before a function definition.  The arguments of the function annotated with the @law macro represent the values of different quantities at a generic integration point. The first argument always represents the coordinate of the integration point. The remaining arguments have arbitrary meaning. In this example, the second argument represents the strain tensor, from which the stress tensor is to be computed using the Lamé operator. Note that the implementation of function σ is very close to its mathematical definition. Under the hood, the @law macro adds an extra method to the annotated function. The newly generated method can be used as σ(ε(u)) in the definition of a bilinear form (as done above), or as σ(ε(uh)), in order to compute the stress tensor associated with a FEFunction object  uh.","category":"page"},{"location":"pages/t003_elasticity/#Solution-of-the-FE-problem-1","page":"3 Linear elasticity","title":"Solution of the FE problem","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The remaining steps for solving the FE problem are essentially the same as in previous tutorial.  We build the triangulation and quadrature for integrating in the volume, we define the terms in the weak form, and we define the FE problem. Finally, we solve it.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"trian = Triangulation(model)\nquad = CellQuadrature(trian,degree=2)\nt_Ω = LinearFETerm(a,trian,quad)\nop = LinearFEOperator(V0,U,t_Ω)\nuh = solve(op)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Note that in the construction of the LinearFEOperator we have used a LinearFETerm instead of an AffineFETerm as it was done in previous tutorial. The LinearFETerm is a particular implementation of FETerm, which only leads to contributions to the system matrix (and not to the right hand side vector). This is what we need here since the body forces are zero. Note also that we do not have explicitly constructed a LinearFESolver. If a LinearFESolver is not passed to the solve function, a default solver is created and used internally.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Finally, we write the results to a file. Note that we also include the strain and stress tensors into the results file.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"writevtk(trian,\"results\",cellfields=[\"uh\"=>uh,\"epsi\"=>ε(uh),\"sigma\"=>σ(ε(uh))])","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"It can be clearly observed (see next figure) that the surface  Gamma_rm B is pulled in x_1-direction and that the solid deforms accordingly.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"(Image: )","category":"page"},{"location":"pages/t003_elasticity/#Multi-material-problems-1","page":"3 Linear elasticity","title":"Multi-material problems","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"We end this tutorial by extending previous code to deal with multi-material problems. Let us assume that the piece simulated before is now made of 2 different materials (see next figure). In particular, we assume that the volume depicted in dark green is made of aluminum, whereas the volume marked in purple is made of steel.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"(Image: )","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The two different material volumes are properly identified in the model we have previously loaded. To check this, inspect the model with Paraview (by writing it to vtk format as done before). Note that the volume made of aluminum is identified as \"material_1\", whereas the volume made of steel is identified as \"material_2\".","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"In order to build the constitutive law for the bi-material problem, we need a vector that contains information about the material each cell in the model is composed. This is achieved by these lines","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"labels = FaceLabels(model)\ndimension = 3\ntags = first_tag_on_face(labels,dimension)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Previous lines generate a vector, namely tags, whose length is the number of cells in the model and for each cell contains an integer that identifies the material of the cell.  This is almost what we need. We also need to know which is the integer value associated with each material. E.g., the integer value associated with \"material_1\" (i.e. aluminum) is retrieved as","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"const alu_tag = tag_from_name(labels,\"material_1\")","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Now, we know that cells whose corresponding value in the tags vector is alu_tag are made of aluminum, otherwise they are made of steel (since there are only two materials in this example).","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"At this point, we are ready to define the multi-material constitutive law. First, we define the material parameters for aluminum and steel respectively:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"function lame_parameters(E,ν)\n  λ = (E*ν)/((1+ν)*(1-2*ν))\n  μ = E/(2*(1+ν))\n  (λ, μ)\nend\n\nconst E_alu = 70.0e9\nconst ν_alu = 0.33\nconst (λ_alu,μ_alu) = lame_parameters(E_alu,ν_alu)\n\nconst E_steel = 200.0e9\nconst ν_steel = 0.33\nconst (λ_steel,μ_steel) = lame_parameters(E_steel,ν_steel)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Then, we define the function containing the constitutive law:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"@law function σ_bimat(x,ε,tag)\n  if tag == alu_tag\n    return λ_alu*tr(ε)*one(ε) + 2*μ_alu*ε\n  else\n    return λ_steel*tr(ε)*one(ε) + 2*μ_steel*ε\n  end\nend","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Note that in this new version of the constitutive law, we have included a third argument that represents the integer value associated with a certain material. If the value corresponds to the one for aluminum (i.e., tag == alu_tag), then, we use the constitutive law for this material, otherwise, we use the law for steel.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Since we have constructed a new constitutive law, we need to re-define the bilinear form of the problem:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"a(v,u) = inner( ε(v), σ_bimat(ε(u),tags) )","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"In previous line, pay attention in the usage of the new constitutive law σ_bimat. Note that we have passed the vector tags containing the material identifiers in the last argument of the function`.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"At this point, we can build the FE problem again and solve it","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"t_Ω = LinearFETerm(a,trian,quad)\nop = LinearFEOperator(V0,U,t_Ω)\nuh = solve(op)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Once the solution is computed, we can store the results in a file for visualization. Note that, we are including the stress tensor in the file (computed with the bi-material law).","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"writevtk(trian,\"results\",cellfields=\n  [\"uh\"=>uh,\"epsi\"=>ε(uh),\"sigma\"=>σ_bimat(ε(uh),tags)])","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Tutorial done!","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/t0041_p_laplacian.jl\"","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"In this tutorial, we will learn","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"How to solve a simple nonlinear PDE in Gridap\nHow to define the weak residual and its Jacobian\nHow to setup and use a nonlinear solver\nHow to define new boundaries from a given discrete model","category":"page"},{"location":"pages/t0041_p_laplacian/#Problem-statement-1","page":"4 p-Laplacian","title":"Problem statement","text":"","category":"section"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"The goal of this tutorial is to solve a nonlinear PDE in Gridap. For the sake of simplicity, we consider the p-Laplacian equation as the model problem. Specifically, the PDE  we want to solve is: find the scalar-field u such that","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"leftlbrace\nbeginaligned\n-nabla cdot left( nabla u^p-2  nabla u right) = f textin Omega\nu = 0  texton  Gamma_0\nu = g  texton  Gamma_g\nleft( nabla u^p-2 nabla u right)cdot n = 0  texton  Gamma_rm N\nendaligned\nright","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"with p2. The computational domain Omega is the one depicted in next figure, which is the same as in the first tutorial. However, we slightly change the boundary conditions here. We impose homogeneous Dirichlet and homogeneous Neumann boundary conditions on Gamma_0 and Gamma_rm N  respectively, and in-homogeneous Dirichlet conditions on Gamma_g. The Dirichlet boundaries Gamma_0 and Gamma_g are defined as the closure of the green and blue surfaces in next figure respectively, whereas the Neumann boundary is Gamma_rm NdoteqpartialOmega setminus (Gamma_0cupGamma_g). In this example, we consider the values p=3, f=1, and g=2.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"(Image: )","category":"page"},{"location":"pages/t0041_p_laplacian/#Numerical-scheme-1","page":"4 p-Laplacian","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We discretize the problem with conforming Lagrangian FE spaces. For this formulation, the nonlinear weak form reads: find uin U_g such that r(u)(v) = 0 for all vin V_0. As in previous tutorials, the space U_g is the set of functions in H^1(Omega) that fulfill the Dirichlet boundary conditions, whereas V_0 is composed by functions in H^1(Omega) that vanish at the Dirichlet boundary. The weak residual r(u) evaluated at a function  uin U_g is the linear form defined as","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"r(u)(v) doteq int_Omega nabla v cdot left( nabla u^p-2 nabla u right)  rm dOmega - int_Omega v f  rm dOmega","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"In order to solve this nonlinear weak equation, we consider a Newton-Raphson method, which is associated with a linearization of the problem in an arbitrary direction delta uin V_0, namely r(u+delta u)(v)approx r(u)(v) + j(u)(vdelta u). In previous formula,  j(u) is the Jacobian evaluated at uin U_g, which is the bilinear form","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"j(u)(vdelta u) = int_Omega nabla v cdot left( nabla u^p-2 nabla delta u right)  rm dOmega + (p-2) int_Omega nabla v cdot left(  nabla u^p-4 (nabla u cdot nabla delta u) nabla u  right)  rm dOmega","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Note that the solution of this nonlinear PDE with a Newton-Raphson method, will require to discretize both the residual r and the Jacobian j. In Gridap, this is done by following an approach similar to the one already shown in previous tutorials for discretizing the bilinear and linear forms associated with a linear FE problem. The specific details are discussed now.","category":"page"},{"location":"pages/t0041_p_laplacian/#Discrete-model-1","page":"4 p-Laplacian","title":"Discrete model","text":"","category":"section"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"As in previous tutorials, the first step to solve the PDE is to load a discretization of the computational domain. In this case, we load the model from the same file as in the first tutorial","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"using Gridap\nmodel = DiscreteModelFromFile(\"../models/model.json\")","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"As stated before, we want to impose Dirichlet boundary conditions on Gamma_0 and Gamma_g,  but none of these boundaries is identified in the model. E.g., you can easily see by writing the model in vtk format","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"writevtk(model,\"model\")","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"and by opening the file \"model_0\" in Paraview that the boundary identified as \"sides\" only includes the vertices in the interior of Gamma_0, but here we want to impose Dirichlet boundary conditions in the closure of Gamma_0, i.e., also on the vertices on the contour of Gamma_0. Fortunately, the objects on the contour of Gamma_0 are identified  with the tag \"sides_c\" (see next figure). Thus, the Dirichlet boundary Gamma_0 can be build as the union of the objects identified as \"sides\" and \"sides_c\".","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"(Image: )","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Gridap provides a convenient way to create new object identifiers (referred to as \"tags\") from existing ones. First, we need to extract from the model, the object that holds the information about the boundary identifiers (referred to as FaceLabels):","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"labels = FaceLabels(model)","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Then, we can add new identifiers (aka \"tags\") to it. In the next line, we create a new tag called \"diri0\" as the union of the objects identified as \"sides\" and \"sides_c\", which is precisely what we need to represent the closure of the Dirichlet boundary Gamma_0.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"add_tag_from_tags!(labels,\"diri0\",[\"sides\", \"sides_c\"])","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We follow the same approach to build a new identifier for the closure of the Dirichlet boundary Gamma_g. In this case, the boundary is expressed as the union of the objects identified with the tags \"circle\", \"circle_c\", \"triangle\", \"triangle_c\", \"square\", \"square_c\". Thus, we create a new tag for  Gamma_g, called \"dirig\" simply as follows:","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"add_tag_from_tags!(labels,\"dirig\",\n  [\"circle\",\"circle_c\", \"triangle\", \"triangle_c\", \"square\", \"square_c\"])","category":"page"},{"location":"pages/t0041_p_laplacian/#FE-Space-1","page":"4 p-Laplacian","title":"FE Space","text":"","category":"section"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Now, we can build the FE space by using the newly defined boundary tags.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"V = FESpace(\n  reffe=:Lagrangian, order=1, valuetype=Float64,\n  conformity=:H1, model=model, labels=labels,\n  diritags=[\"diri0\", \"dirig\"])","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"The construction of this space is essentially the same as in the first tutorial (we build a continuous scalar-valued Lagrangian interpolation of first order). However, we also pass here the labels object (that contains the newly created boundary tags). From this FE space, we define the test and trial FE spaces","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"g = 1.0\nV0 = TestFESpace(V)\nUg = TrialFESpace(V,[0.0,g])","category":"page"},{"location":"pages/t0041_p_laplacian/#Nonlinear-FE-problem-1","page":"4 p-Laplacian","title":"Nonlinear FE problem","text":"","category":"section"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"At this point, we are ready to build the nonlinear FE problem. To this end, we need to define the weak residual and also its corresponding Jacobian. This is done following a similar procedure to the one considered in previous tutorials to define the bilinear and linear forms associated with linear FE problems. In this case, instead of an AffineFETerm (which is for linear problems), we use a NonLinearFETerm. An instance of NonLinearFETerm is constructed by providing the integrands of the weak residual and its Jacobian (in a similar way an AffineFETerm is constructed from the integrands of the bilinear and linear forms).","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"On the one hand, the integrand of the weak residual is build as follows","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"using LinearAlgebra: norm\nconst p = 3\n@law flux(x,∇u) = norm(∇u)^(p-2) * ∇u\nf(x) = 1.0\nres(u,v) = inner( ∇(v), flux(∇(u)) ) - inner(v,f)","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Function res is the one representing the integrand of the weak residual r(u)(v). The first argument of function res stands for the function uin U_g, where the residual is evaluated, and the second argument stands for a generic test function vin V_0. Note that we have used the macro @law to construct the \"constitutive  law\" that relates the nonlinear flux with the gradient of the solution.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"On the other hand,  we implement a function jac representing the integrand of the Jacobian","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"@law dflux(x,∇du,∇u) =\n  (p-2)*norm(∇u)^(p-4)*inner(∇u,∇du)*∇u + norm(∇u)^(p-2) * ∇du\njac(u,v,du) = inner(  ∇(v) , dflux(∇(du),∇(u)) )","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"The first argument of function jac stands for function uin U_g, where the Jacobian is evaluated. The second argument is a test function vin V_0, and the third argument represents an arbitrary direction delta u in V_0. Note that we have also used the macro @law to define the linearization of the nonlinear flux.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"With these functions, we build the NonLinearFETerm as follows:","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"trian = Triangulation(model)\nquad = CellQuadrature(trian,degree=2)\nt_Ω = NonLinearFETerm(res,jac,trian,quad)","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We build the NonLinearFETerm by passing in the first and second arguments the functions that represent the integrands of the residual and Jacobian respectively. The other two arguments, are the triangulation and quadrature used to perform the integrals numerically. From this NonLinearFETerm object, we finally construct the nonlinear FE problem","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"op = NonLinearFEOperator(V,Ug,t_Ω)","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Here, we have constructed an instance of NonLinearFEOperator, which is the type that represents a general nonlinear FE problem in Gridap. The constructor takes the test and trial spaces, and the FETerms objects describing the corresponding weak form (in this case only a single term).","category":"page"},{"location":"pages/t0041_p_laplacian/#Nonlinear-solver-phase-1","page":"4 p-Laplacian","title":"Nonlinear solver phase","text":"","category":"section"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We have already built the nonlinear FE problem. Now, the remaining step is to solve it. In Gridap, nonlinear (and also linear) FE problems can be solved with instances of the type NonLinearFESolver. The type NonLinearFESolver is a concrete implementation of the abstract type FESolver particularly designed for nonlinear problems (in contrast to the concrete type LinearFESolver which is for the linear case).","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We construct an instance of NonLinearFESolver as follows:","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"using LineSearches: BackTracking\nnls = NLSolver(\n  show_trace=true, method=:newton, linesearch=BackTracking())\nsolver = NonLinearFESolver(nls)","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Note that the NLSolver function used above internally calls the nlsolve function of the NLsolve package with the provided key-word arguments. Thus, one can use any of the nonlinear methods available via the function nlsolve to solve the nonlinear FE problem. Here, we have selected a Newton-Raphson method with a back-tracking line-search from the LineSearches package.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We are finally in place to solve the nonlinear FE problem. The initial guess is a FEFunction, which we build from a vector of random (free) nodal values:","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"import Random\nRandom.seed!(1234)\nx = rand(Float64,num_free_dofs(Ug))\nuh0 = FEFunction(Ug,x)\nuh, = solve!(uh0,solver,op)","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We finish this tutorial by writing the computed solution for visualization (see next figure).","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"writevtk(trian,\"results\",cellfields=[\"uh\"=>uh])","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"(Image: )","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Welcome to the tutorial pages of the Gridap.jl project.","category":"page"},{"location":"#How-to-start-1","page":"Introduction","title":"How to start","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The easiest way to start using the tutorials is to click in one of the following links to start reading the html version of the tutorial you want.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Depth = 1","category":"page"},{"location":"#Jupyter-notebooks-1","page":"Introduction","title":"Jupyter notebooks","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"In addition, the tutorials are available as jupyter notebooks. You can access them in three different ways:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"By running the notebooks locally. A working installation of Julia in the system is required. See instructions below. This is the recommended way to follow the tutorials. In particular, it allows to inspect the generated results with Paraview.\nBy running the notebook remotely via binder. In that case, go to the desired tutorial and click the icon (Image: ). No local installation of Julia needed.\nBy reading a non-interactive version of the notebook via nbviewer. In that case, go to the desired tutorial and click the icon (Image: )","category":"page"},{"location":"#How-to-run-the-notebooks-locally-1","page":"Introduction","title":"How to run the notebooks locally","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Clone the repository","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"$ git clone https://github.com/gridap/Tutorials.git","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Move into the folder and open a Julia REPL setting the current folder as the project environment. NOTE: use at least Julia 1.1","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"$ cd Tutorials\n$ julia --project=.\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.1.0 (2019-01-21)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> \n","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Instantiate the environment. This will automatically download all required packages.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"# Type ] to enter in pkg mode\n(Tutorials) pkg> instantiate","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Build the notebooks","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"# Type Ctrl+C to get back to command mode\njulia> include(\"deps/build.jl\")","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Open the notebooks","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> using IJulia\njulia> notebook(dir=pwd())","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This will open a browser window. Navigate to the notebooks folder and open the tutorial you want. Enjoy!","category":"page"},{"location":"#How-to-pull-the-latest-version-of-the-tutorials-1","page":"Introduction","title":"How to pull the latest version of the tutorials","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you have cloned the repository a while ago, you can update to the newest version with these steps.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Go to the Tutorials repo folder and git pull","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"$ git pull","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Open Julia REPL","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"$ julia --project=.\n","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"and instantiate the environment and build the notebooks again","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"# Type ] to enter in pkg mode\n(Tutorials) pkg> instantiate\n\n# Type Ctrl+C to get back to command mode\njulia> include(\"deps/build.jl\")","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Done!","category":"page"}]
}
