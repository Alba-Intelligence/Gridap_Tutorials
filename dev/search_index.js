var documenterSearchIndex = {"docs":
[{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/t004_hyperelasticity.jl\"","category":"page"},{"location":"pages/t004_hyperelasticity/#Tutorial-5:-Hyperelasticity-1","page":"5 Hyper-elasticity","title":"Tutorial 5: Hyperelasticity","text":"","category":"section"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t004_hyperelasticity/#Problem-statement-1","page":"5 Hyper-elasticity","title":"Problem statement","text":"","category":"section"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"using Gridap\nusing LinearAlgebra: inv, det\nusing LineSearches: BackTracking","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Material parameters","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"const λ = 100.0\nconst μ = 1.0","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Deformation Gradient","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"F(∇u) = one(∇u) + ∇u'\n\nJ(F) = sqrt(det(C(F)))\n\n#Green strain\n\n#E(F) = 0.5*( F'*F - one(F) )\n\n@law dE(x,∇du,∇u) = 0.5*( ∇du*F(∇u) + (∇du*F(∇u))' )","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Right Cauchy-green deformation tensor","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"C(F) = (F')*F","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Constitutive law (Neo hookean)","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"@law function S(x,∇u)\n  Cinv = inv(C(F(∇u)))\n  μ*(one(∇u)-Cinv) + λ*log(J(F(∇u)))*Cinv\nend\n\n@law function dS(x,∇du,∇u)\n  Cinv = inv(C(F(∇u)))\n  _dE = dE(x,∇du,∇u)\n  λ*inner(Cinv,_dE)*Cinv + 2*(μ-λ*log(J(F(∇u))))*Cinv*_dE*(Cinv')\nend","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Cauchy stress tensor","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"@law σ(x,∇u) = (1.0/J(F(∇u)))*F(∇u)*S(x,∇u)*(F(∇u))'","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Weak form","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"res(u,v) = inner( dE(∇(v),∇(u)) , S(∇(u)) )\n\njac_mat(u,v,du) = inner( dE(∇(v),∇(u)), dS(∇(du),∇(u)) )\n\njac_geo(u,v,du) = inner( ∇(v), S(∇(u))*∇(du) )\n\njac(u,v,du) = jac_mat(u,v,du) + jac_geo(u,v,du)","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Model","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"model = CartesianDiscreteModel(domain=(0.0,1.0,0.0,1.0), partition=(20,20))","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Define new boundaries","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"labels = FaceLabels(model)\nadd_tag_from_tags!(labels,\"diri_0\",[1,3,7])\nadd_tag_from_tags!(labels,\"diri_1\",[2,4,8])","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Construct the FEspace","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"order = 1\ndiritags = [\"diri_0\", \"diri_1\"]\nT = VectorValue{2,Float64}\nfespace = CLagrangianFESpace(T,model,labels,order,diritags)\nV = TestFESpace(fespace)","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Setup integration","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"trian = Triangulation(model)\nquad = CellQuadrature(trian,order=2)","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Setup weak form terms","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"t_Ω = NonLinearFETerm(res,jac,trian,quad)","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Setup non-linear solver","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"nls = JuliaNLSolver(\n  show_trace=true,\n  method=:newton,\n  linesearch=BackTracking())\n\nsolver = NonLinearFESolver(nls)\n\n\nfunction run(x0,disp_x,step,nsteps)\n\n  g0 = zero(T)\n  g1 = VectorValue(disp_x,0.0)\n  U = TrialFESpace(fespace,[g0,g1])\n\n  #FE problem\n  op = NonLinearFEOperator(V,U,t_Ω)\n\n  println(\"\\n+++ Solving for disp_x $disp_x in step $step of $nsteps +++\\n\")\n\n  uh = FEFunction(U,x0)\n\n  solve!(uh,solver,op)\n\n  writevtk(trian,\"results_$(lpad(step,3,'0'))\",cellfields=[\"uh\"=>uh,\"sigma\"=>σ(∇(uh))])\n\n  return free_dofs(uh)\n\nend\n\nfunction runs()\n\n disp_max = 0.75\n disp_inc = 0.02\n nsteps = ceil(Int,abs(disp_max)/disp_inc)\n\n x0 = zeros(Float64,num_free_dofs(fespace))\n\n for step in 1:nsteps\n   disp_x = step * disp_max / nsteps\n   x0 = run(x0,disp_x,step,nsteps)\n end\n\nend\n\n#Do the work!\nruns()","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Picture of the last load step (Image: )","category":"page"},{"location":"pages/t004_hyperelasticity/#Extension-to-3D-1","page":"5 Hyper-elasticity","title":"Extension to 3D","text":"","category":"section"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"Extending this tutorial to the 3D case is straightforward. It is leaved as an exercise.","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"(Image: )","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"5 Hyper-elasticity","title":"5 Hyper-elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/t002_validation.jl\"","category":"page"},{"location":"pages/t002_validation/#Tutorial-2:-Code-validation-1","page":"2 Code validation","title":"Tutorial 2: Code validation","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t002_validation/#Learning-outcomes-1","page":"2 Code validation","title":"Learning outcomes","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"How to implement the method of manufactured solutions\nHow to perform a convergence test\nHow to define the discretization error\nHow to integrate error norms\nHow to generate Cartesian meshes in arbitrary dimensions","category":"page"},{"location":"pages/t002_validation/#Problem-statement-1","page":"2 Code validation","title":"Problem statement","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In this tutorial, we show how to validate a code using the well known method of manufactured solutions. For the sake of simplicity, we consider the Poisson equation in the unit square Omegadoteq (01)^2 as a model problem,","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton partialOmega\nendaligned\nright","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We are going to consider two different manufactured solutions. On the one hand, we consider function u(x)=x_1+x_2, which can be exactly represented by the FE interpolation that we construct below. Thus, one expects that the obtained approximation error is near the machine precision. We are going to check that this is true in the code. On the other hand, we consider a function that cannot be captured exactly by the interpolation, namely u(x)=x_2 sin(2 pi x_1). Here, our goal is to confirm that the convergence order of the discretization error is the optimal one.","category":"page"},{"location":"pages/t002_validation/#Manufactured-solution-1","page":"2 Code validation","title":"Manufactured solution","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We start by defining the manufactured solution u(x) = x_1+x_2 and the source term f associated with it, namely fdoteq-Delta(x_1+x_2)=0.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"using Gridap\n\nu(x) = x[1] + x[2]\nf(x) = 0.0","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Note that it is important that function f returns a Float64 value. This is needed since we are going to use Float64 numbers to represent the solution.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We also need to define the gradient of u since we will compute the H^1 error norm later. In that case, the gradient is simply defined as","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"∇u(x) = VectorValue(1.0,1.0)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Note that we have used the constructor VectorValue to build the vector that represents the gradient. However, we still need a final trick. We need to tell the Gridap library that the gradient of the function u is available in the function ∇u (at this moment u and ∇u are two standard Julia functions without any connection between them). This is done by adding an extra method to the function gradient (aka ∇) defined in Gridap:","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"import Gridap: ∇\n∇(::typeof(u)) = ∇u","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Now, it is possible to recover function ∇u from function u as ∇(u). You can check that the following expression evaluates to true.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"∇(u) === ∇u","category":"page"},{"location":"pages/t002_validation/#Cartesian-mesh-generation-1","page":"2 Code validation","title":"Cartesian mesh generation","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In order to discretize the geometry of the unit square, we use the Cartesian mesh generator available in Gridap:","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"limits = (0.0, 1.0, 0.0, 1.0)\nmodel = CartesianDiscreteModel(domain=limits, partition=(4,4));","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The type CartesianDiscreteModel is a concrete type that inherits from DiscreteModel, which is specifically designed for building Cartesian meshes. The CartesianDiscreteModel constructor takes a tuple containing limits of the box we want to discretize  plus a tuple with the number of cells to be generated in each direction (here 4 by 4 cells). Note that the CaresianDiscreteModel is implemented for arbitrary dimensions. For instance, the following lines build a CartesianDiscreteModel  for the unit cube (01)^3 with 4 cells per direction","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"limits3d = (0.0, 1.0, 0.0, 1.0, 0.0, 1.0)\nmodel3d = CartesianDiscreteModel(domain=limits3d, partition=(4,4,4));","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"You could also generate a mesh for the unit tesseract (01)^4 (i.e., the unit cube in 4D). Look how the 2D and 3D models are build and just follow the sequence.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Let us return to the 2D CartesianDiscreteModel that we have already constructed. You can inspect it by writing it into vtk format. Note that you can also print a 3D model, but not a 4D one. In the future, it would be cool to generate a movie from a 4D model, but this functionality is not yet implemented.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"writevtk(model,\"model\");","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"If you open the generated files, you will see that the boundary vertices and facets are identified with the name \"boundary\". This is just what we need to impose the Dirichlet boundary conditions in this example.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"These are the vertices in the model","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"(Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"and these the facets","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"(Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"As you can see in the pictures, the objects on the boundary are correctly tagged with the name \"boundary\".","category":"page"},{"location":"pages/t002_validation/#FE-approximation-1","page":"2 Code validation","title":"FE approximation","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We compute a FE approximation of the Poisson problem above by following the steps detailed in the previous tutorial:","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"order = 1\ndiritag = \"boundary\"\nV = CLagrangianFESpace(Float64,model,order,diritag)\n\nV0 = TestFESpace(V)\nU = TrialFESpace(V,u)\n\ntrian = Triangulation(model)\nquad = CellQuadrature(trian,order=2)\n\na(v,u) = inner(∇(v), ∇(u))\nb(v) = inner(v,f)\n\nt_Ω = AffineFETerm(a,b,trian,quad)\nop = LinearFEOperator(V0,U,t_Ω)\n\nuh = solve(op);","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Note that we are imposing Dirichlet boundary conditions on the objects tagged as \"boundary\" and that we are using the manufactured solution u to construct the trial FE space. Not also that we are not explicitly constructing an Assembler object nor a FESolver. We are relying on default values.","category":"page"},{"location":"pages/t002_validation/#Measuring-the-discretization-error-1","page":"2 Code validation","title":"Measuring the discretization error","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Our goal is to check that the discratization error associated with the computed approximation uh is close to machine precision. To this end, the first step is to compute the discretization error, which is done as you would expect:","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"e = u - uh;","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Once the error is defined, you can, e.g., visualize it.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"writevtk(trian,\"error\",cellfields=[\"e\" => e]);","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"This generates a file called error.vtu. Open it with Paraview to check that the error is of the order of the machine precision.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"(Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"A more rigorous way of quantifying the error is to measure it with a norm. Here, we use the L^2 and H^1 norms, which are defined as","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":" w _L^2^2 doteq int_Omega w^2  textdOmega quad\n w _H^1^2 doteq int_Omega w^2 + nabla w cdot nabla w  textdOmega","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In order to compute these norms, we are going to use the integrate function. To this end, we need to define the integrands that we want to integrate, namely","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"l2(w) = inner(w,w)\nh1(w) = a(w,w) + l2(w)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Note that in order to define the integrand of the H^1 norm, we have reused function a, previously used to define the bilinear form of the problem.  Once we have defined the integrands, we are ready to compute the integrals. For the L^2 norm","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"el2 = sqrt(sum( integrate(l2(e),trian,quad) ))","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"and for the H^1 norm","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"eh1 = sqrt(sum( integrate(h1(e),trian,quad) ))","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The integrate function works as follows. In the first argument, we pass the integrand. In the second and third arguments, we pass a Triangulation object and aCellQuadrature that represent the data needed in order to perform the integrals numerically. The integrate function returns an object containing the contribution to the integrated value of each cell in the given Triangulation. To end up with the desired error norms, one has to sum these contributions and take the square root. You can check that the computed error norms are close to machine precision (as one would expect).","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"tol = 1.e-10\n@assert el2 < tol\n@assert eh1 < tol","category":"page"},{"location":"pages/t002_validation/#Convergence-test-1","page":"2 Code validation","title":"Convergence test","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We end up this tutorial by performing a convergence test, where we are going to use all the new concepts we have learned.  We will consider a manufactured solution that does not belong to the FE interpolation space. In this test, we expect to see the optimal convergence order of the FE discretization.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Here, we define the manufactured functions","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"const k = 2*pi\nu(x) = sin(k*x[1]) * x[2]\n∇u(x) = VectorValue(k*cos(k*x[1])*x[2], sin(k*x[1]))\nf(x) = (k^2)*sin(k*x[1])*x[2]","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Since we have redefined the valiables u, ∇u, and f, we need to execute these lines again","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"∇(::typeof(u)) = ∇u\nb(v) = inner(v,f)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In order to perform the convergence test, we write in a function all the code needed to perform a single computation and measure its error. The input of this function is the number of cells in each direction and the interpolation order. The output is the computed L^2 and H^1 error norms.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"function run(n,order)\n\n  limits = (0.0, 1.0, 0.0, 1.0)\n  model = CartesianDiscreteModel(domain=limits, partition=(n,n))\n\n  diritag = \"boundary\"\n  V = CLagrangianFESpace(Float64,model,order,diritag)\n\n  V0 = TestFESpace(V)\n  U = TrialFESpace(V,u)\n\n  trian = Triangulation(model)\n  quad = CellQuadrature(trian,order=order+2)\n\n  t_Ω = AffineFETerm(a,b,trian,quad)\n  op = LinearFEOperator(V0,U,t_Ω)\n\n  uh = solve(op)\n\n  e = u - uh\n\n  el2 = sqrt(sum( integrate(l2(e),trian,quad) ))\n  eh1 = sqrt(sum( integrate(h1(e),trian,quad) ))\n\n  (el2, eh1)\n\nend","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The following function does the convergence test. It takes a vector of integers (representing the number of cells per direction in each computation) plus the interpolation order. It returns the L^2 and H^1 error norms for each computation as well as the corresponding cell size.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"function conv_test(ns,order)\n\n  el2s = Float64[]\n  eh1s = Float64[]\n  hs = Float64[]\n\n  for n in ns\n\n    el2, eh1 = run(n,order)\n    h = 1.0/n\n\n    push!(el2s,el2)\n    push!(eh1s,eh1)\n    push!(hs,h)\n\n  end\n\n  (el2s, eh1s, hs)\n\nend","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We are ready to perform the test! We consider several mesh sizes and interpolation order equal to 2.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"el2s, eh1s, hs = conv_test([8,16,32,64,128],2);","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"With the generated data, we do the classical convergence plot.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"using Plots\n\nplot(hs,[el2s eh1s],\n    xaxis=:log, yaxis=:log,\n    label=[\"L2\" \"H1\"],\n    shape=:auto,\n    xlabel=\"h\",ylabel=\"error norm\")","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"If you run the code in a notebook, you will see a figure like this one: (Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The generated curves make sense. It is observed that the convergence of the H^1 error is slower that L^2 one. However, in order to be more conclusive, we need to compute the slope of these lines. It can be done with this little function that internally uses a linear regression.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"function slope(hs,errors)\n  x = log10.(hs)\n  y = log10.(errors)\n  linreg = hcat(fill!(similar(x), 1), x) \\ y\n  linreg[2]\nend","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The slope for the L^2 error norm is computed as","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"slope(hs,el2s)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"and for the H^1 error norm","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"slope(hs,eh1s)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"If your run these lines in a notebook, you will see that the slopes for the L^2 and H^1 error norms are circa 3 and 2 respectively (as one expects for interpolation order 2)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Congrats, another tutorial done!","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/t001_poisson.jl\"","category":"page"},{"location":"pages/t001_poisson/#Tutorial-1:-Poisson-equation-1","page":"1 Poisson equation","title":"Tutorial 1: Poisson equation","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t001_poisson/#Learning-outcomes-1","page":"1 Poisson equation","title":"Learning outcomes","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"How to solve a simple PDE in Julia with Gridap\nHow to load a discrete model (aka a FE mesh) from a file\nHow to build Conforming Lagrangian FE spaces\nHow to define the different terms in a weak form\nHow to impose Dirichlet and Neumann boundary conditions\nHow to visualize results","category":"page"},{"location":"pages/t001_poisson/#Problem-statement-1","page":"1 Poisson equation","title":"Problem statement","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"We want to solve the Poisson equation on the 3D domain depicted in the figure below with Dirichlet and Neumann boundary conditions. Dirichlet boundary conditions are applied on Gamma_rm D, being the outer sides of the prism (marked in red). Non-homogeneous Neumann conditions are applied to the internal boundaries Gamma_rm G, Gamma_rm Y, and Gamma_rm B (marked in green, yellow and blue respectively). And homogeneous Neumann boundary conditions are applied in Gamma_rm W, the remaining portion of the boundary (marked in white).","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: model)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Formally, the problem to solve is: find u such that","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton Gamma_rm D\nnabla ucdot n = h  texton  Gamma_rm N\nendaligned\nright","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"being n the outwards unit normal vector to the Neumann boundary Gamma_rm N doteq Gamma_rm GcupGamma_rm YcupGamma_rm BcupGamma_rm W. For simplicity, we chose f(x) = 1, g(x) = 2, and h(x)=3 on Gamma_rm GcupGamma_rm YcupGamma_rm B and h(x)=0 on Gamma_rm W. The variable x is the position vector x=(x_1x_2x_3).","category":"page"},{"location":"pages/t001_poisson/#Numerical-scheme-1","page":"1 Poisson equation","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In this first tutorial, we use a conventional Galerkin finite element (FE) method with conforming Lagrangian finite element spaces. The model problem reduces to the weak equation: find uin U_g such that $ a(v,u) = b(v) $ for all vin V_0, where U_g and V_0 are the subset of functions in H^1(Omega) that fulfill the Dirichlet boundary condition g and 0 respectively. The bilinear and linear forms for this problems are","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"a(vu) doteq int_Omega nabla v cdot nabla u  rm dOmega quad b(v) doteq int_Omega v f   rm  dOmega + int_Gamma_rm N v g  rm dGamma_rm N","category":"page"},{"location":"pages/t001_poisson/#Implementation-1","page":"1 Poisson equation","title":"Implementation","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In order to solve this problem in Gridap,  we are going to build the main objects that are involved in the weak formulation.  The step number 0 is to load the Gridap project. If you have configured your environment properly, it is simply done like this:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"using Gridap","category":"page"},{"location":"pages/t001_poisson/#Discrete-model-1","page":"1 Poisson equation","title":"Discrete model","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"As in any FE simulation, we need a discretization of the computational domain (i.e a FE mesh), which contains information of the different boundaries to impose boundary conditions. All geometrical data needed for solving a FE problem is provided in Gridap by types inheriting from the abstract type DiscreteModel. In the following line, we build an instance of DiscreteModel by loading a model from a json file.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"model = DiscreteModelFromFile(\"../models/model.json\");","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"You can easily inspect the generated model in Paraview by writing it in vtk format.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"writevtk(model,\"model\");","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The previous line generates four different files model_0.vtu, model_1.vtu, model_2.vtu, and model_3.vtu containing the vertices, edges, faces, and cells present in the discrete model. Moreover, you can easily inspect which boundaries are defined within the model.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"For instance, if we want to see which faces of the model are on the boundary Gamma_rm B (i.e., the walls of the circular hole), open the file model_2.vtu and chose coloring by the element field \"circle\". You should see that only the faces on the circular hole have a value different from 0.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: )","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"It is also possible to see which vertices are on the Dirichlet boundary Gamma_rm D. To do so, open the file model_0.vtu and chose coloring by the field \"sides\".","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: )","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"That is, the boundary Gamma_rm B (i.e., the walls of the circular hole) is called \"circle\" and the Dirichlet boundary Gamma_rm D is called \"sides\" in the model. In addition, the walls of the triangular hole Gamma_rm G and the walls of the square hole Gamma_rm Y are identified in the model with the names \"triangle\" and \"square\" respectively.","category":"page"},{"location":"pages/t001_poisson/#FE-spaces-1","page":"1 Poisson equation","title":"FE spaces","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Once we have a discretization of the computational domain, the next step is to generate a discrete approximation of the finite element spaces V_0 and U_g (i.e. the test and trial FE spaces) of the problem. To do so, first, we are going to build a discretization of H^1(Omega), namely V, defined as the standard Conforming Lagrangian FE space (without boundary conditions) associated with the discretization of the computational domain. Note that functions in V are free on the Dirichlet boundary (which is not the case for V_0 and U_g). The FE space V is build as follows:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"order = 1\ndiritag = \"sides\"\nV = CLagrangianFESpace(Float64,model,order,diritag);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In the first argument, we pass the data type that represents the value of the functions in the space. In that case, Float64 since the unknown of our problem is scalar-valued and it will be represented with a 64-bit floating point number. In addition, we pass the model on top of which we want to construct the space, the interpolation order, and the name of the entities that are on the Dirichlet boundary. Note that, even though functions in V are not constrained by Dirichlet boundary conditions, the underlaying implementation is aware of which functions have support on the Dirichlet boundary. This is why we need to pass the argument diritag.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The approximations for the test and trial spaces V_0 and U_g are build simply as","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"g(x) = 2.0\nV0 = TestFESpace(V)\nUg = TrialFESpace(V,g);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Note that functions in the test space are always constrained to 0 on the Dirichlet boundary, whereas functions on the trial space are constrained to the given boundary function. In this case, function g.","category":"page"},{"location":"pages/t001_poisson/#Numerical-integration-1","page":"1 Poisson equation","title":"Numerical integration","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Once we have build the interpolation spaces, the next step is to set up the machinery to perform the integrals in the weak form numerically. Here, we need to compute integrals on the interior of the domain Omega and on the Neumann boundary Gamma_rm N. In both cases, we need two main ingredients. We need to define an integration mesh (i.e. a set of cells that form a partition of the integration domain), plus a Gauss-like quadrature in each of the cells. In Gridap, integration meshes are represented by types inheriting from the abstract type Triangulation. For integrating on the domain Omega, we build the following integration mesh and quadrature:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"trian = Triangulation(model)\nquad = CellQuadrature(trian,order=2);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Note that in this simple case, we are using the cells of the model as integration cells, but in more complex formulations (e.g., embedded finite element computations) the integration cells can be different from the cells on the background FE mesh. Note also, that we are constructing a quadrature of order 2 in the cells of the integration mesh. This is enough for integrating all terms of the weak form exactly for an interpolation of order 1.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"On the other hand, we need a special type of integration mesh, represented by the type BoundaryTriangulation, to integrate on the boundary. We build an instance of this type from the discrete model and the names used to identify the Neumann boundary as follows:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"neumanntags = [\"circle\", \"triangle\", \"square\"]\nbtrian = BoundaryTriangulation(model,neumanntags)\nbquad = CellQuadrature(btrian,order=2);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Note that we have also created a quadrature of order 2 on top of the integration mesh for the Neumann boundary.","category":"page"},{"location":"pages/t001_poisson/#Weak-form-1","page":"1 Poisson equation","title":"Weak form","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"With all the ingredients presented so far, we are ready to define our FE problem.  First, we need to define the weak form of the problem at hand. This is done by means of types inheriting from the abstract type FETerm. In this tutorial, we will use the sub-types AffineFETerm and FESource. An AffineFETerm is a term that contributes both to the system matrix and the right-hand-side vector, whereas a FESource only contributes to the right hand side vector.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In this example, we use an AffineFETerm to represent all the terms in the weak form that are integrated over the interior of the domain Omega. It is constructed like this:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"f(x) = 1.0\na(v,u) = inner( ∇(v), ∇(u) )\nb_Ω(v) = inner(v, f)\nt_Ω = AffineFETerm(a,b_Ω,trian,quad);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In the first argument, we pass a function that represents the integrand of the bilinear form a(cdotcdot), the second argument is a function that represents the integrand of part of the linear form b(cdot) that is integrated over the domain Omega. The third argument is the Triangulation on which we want to perform the integration (in that case the integration mesh for Omega), and the last argument is the CellQuadrature needed to perform the integration numerically.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Note that the contribution associated with the Neumann condition is integrated over a different domain, and thus, cannot be included in the previous AffineFETerm. To account for it, we use a FESource object:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"h(x) = 3.0\nb_Γ(v) = inner(v, h)\nt_Γ = FESource(b_Γ,btrian,bquad);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Here, we pass in the first argument the integrand of the Neumann boundary condition, and in the last arguments we pass the integration mesh and quadrature for the Neumann boundary.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Presenting the precise notation used to define the integrands of the weak form is out of the scope of this first tutorial. But for the moment, the following remarks are enough. Variables v and u  represents a test and trial function respectively. The function ∇ represents the gradient operator. The function inner represents the inner product. It is extremely important to be aware that the implementation of the inner function is not commutative! The first argument is always for the test function (which will be associated with the rows of the system matrix or the right hand side vector depending on the case). Not following this rule can end up with matrices that are the transpose of the matrix you really want or with code crashes in the worst case. Note that we have always correctly placed the test function v in the first argument.","category":"page"},{"location":"pages/t001_poisson/#FE-problem-1","page":"1 Poisson equation","title":"FE problem","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"At this point, we can combine all ingredients and formulate our FE problem. A FE problem (both for linear and nonlinear cases) is represented in the code by types inheriting from the abstract type FEOperator. Since we want to solve a linear problem, we use the concrete type LinearFEOperator:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"assem = SparseMatrixAssembler(V0,Ug)\nop = LinearFEOperator(V0,Ug,assem,t_Ω,t_Γ);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Note that we build the LinearFEOperator object from the test and trial FE spaces and the FE terms constructed before. We also need to provide an Assembler object, which represents the strategy to assemble the system. In this case, we use a SparseMatrixAssembler, which will use Julia build-in sparse matrices.","category":"page"},{"location":"pages/t001_poisson/#Solver-phase-1","page":"1 Poisson equation","title":"Solver phase","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"We have constructed a FE problem, the last step is to solve it. In Gridap, FE problems are solved with types inheriting from the abstract type FESolver. Since this is a linear problem, we use a LinearFESolver:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"ls = LUSolver()\nsolver = LinearFESolver(ls)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"LinearFESolver objects are build from a given algebraic linear solver. In this case, we use a LU factorization. Now we are ready to solve the problem as follows:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"uh = solve(solver,op);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The solution of the problem uh is an instance of FEFunction, the type used to represent a function in a FE space. We can inspect the result by writing it into a vtk file:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"writevtk(trian,\"results\",cellfields=[\"uh\"=>uh]);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"which will generate a file named results.vtu having a nodal field named uh containing the solution of our problem. If you open it, you will see something like this:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: )","category":"page"},{"location":"pages/t001_poisson/#Summary-1","page":"1 Poisson equation","title":"Summary","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Since this has been a quite long tutorial, we end up by wrapping all the code we have used.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"using Gridap\n\n#Read the discrete model\nmodel = DiscreteModelFromFile(\"../models/model.json\")\n\n#Setup FE space\norder = 1\ndiritag = \"sides\"\nV = CLagrangianFESpace(Float64,model,order,diritag)\n\n#Setup test and trial spaces\ng(x) = 2.0\nV0 = TestFESpace(V)\nUg = TrialFESpace(V,g)\n\n#Setup numerical integration (volume)\ntrian = Triangulation(model)\nquad = CellQuadrature(trian,order=2)\n\n#Setup numerical integration (boundary)\nneumanntags = [\"circle\", \"triangle\", \"square\"]\nbtrian = BoundaryTriangulation(model,neumanntags)\nbquad = CellQuadrature(btrian,order=2)\n\n#Setup FE terms (volume)\nf(x) = 1.0\na(v,u) = inner( ∇(v), ∇(u) )\nb_Ω(v) = inner(v, f)\nt_Ω = AffineFETerm(a,b_Ω,trian,quad)\n\n#Setup FE terms (boundary)\nh(x) = 3.0\nb_Γ(v) = inner(v, h)\nt_Γ = FESource(b_Γ,btrian,bquad)\n\n#Setup FE problem\nassem = SparseMatrixAssembler(V0,Ug)\nop = LinearFEOperator(V0,Ug,assem,t_Ω,t_Γ)\n\n#Solve it!\nls = LUSolver()\nsolver = LinearFESolver(ls)\nuh = solve(solver,op)\n\n#Write results\nwritevtk(trian,\"results\",cellfields=[\"uh\"=>uh])","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Congrats, tutorial done!","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/t003_elasticity.jl\"","category":"page"},{"location":"pages/t003_elasticity/#Tutorial-3:-Linear-elasticity-1","page":"3 Linear elasticity","title":"Tutorial 3: Linear elasticity","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t003_elasticity/#Learning-outcomes-1","page":"3 Linear elasticity","title":"Learning outcomes","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"How to approximate vector-valued problems\nHow to solve problems with complex constitutive laws\nHow to impose Dirichlet boundary conditions only in selected components\nHow to impose Dirichlet boundary conditions described by more than one function\nHow to deal with multi-material problems","category":"page"},{"location":"pages/t003_elasticity/#Problem-statement-1","page":"3 Linear elasticity","title":"Problem statement","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"In this tutorial, we detail how to solve a linear elasticity problem. We consider the geometry depicted in the next figure.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"(Image: )","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The mechanical problem is defined with the following boundary conditions. All components of the displacement vector are constrained to zero on the surface Gamma_rm G, which is marked in green in the figure. On the other hand, the first component of the displacement vector is prescribed to the value deltadoteq 5mm on the surface Gamma_rm B, which is marked in blue. No body or surface forces are included in this example.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The PDE to solve is","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"leftlbrace\nbeginaligned\n-cdotsigma(u) = 0  textin  Omega\nu = 0  texton Gamma_rm G\nu_1 = delta  texton Gamma_rm B\nsigma(u)cdot n = 0  texton  Gamma_rm N\nendaligned\nright","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The variable u stands for the unknown displacement vector. The vector n is the unit outward normal to the Neumann boundary Gamma_rm NdoteqpartialOmegasetminusleft(Gamma_rm BcupGamma_rm Gright) and sigma(u) is the stress tensor defined as","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"sigma(u) doteq lambda rm tr(varepsilon(u))  I +2 mu   varepsilon(u)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"where I is the 2nd order identity tensor, lambda and mu are the Lamé parameters of the material, and varepsilon(u)doteqfrac12left(nabla u + (nabla u)^t right) is the symmetric gradient (i.e., the strain tensor).","category":"page"},{"location":"pages/t003_elasticity/#Numerical-scheme-1","page":"3 Linear elasticity","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"In this tutorial, we use a conventional Galerkin FE method with conforming Lagrangian FE spaces. For this formulation, the weak version of the problem is find uin U such that $ a(v,u) = 0 $ for all vin V_0, where U is the subset of functions in VdoteqH^1(Omega)^3 that fulfill the Dirichlet boundary conditions of the problem, whereas V_0 are functions in V fulfilling v=0 on Gamma_rm G and v_1=0 on Gamma_rm B. The bilinear form of the problem is","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"a(vu)doteq int_Omega varepsilon(v)  sigma(u)  rm dOmega","category":"page"},{"location":"pages/t003_elasticity/#Implementation-1","page":"3 Linear elasticity","title":"Implementation","text":"","category":"section"},{"location":"pages/t003_elasticity/#Discrete-model-1","page":"3 Linear elasticity","title":"Discrete model","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"We start by loading the discrete model from a file","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"using Gridap\n\nmodel = DiscreteModelFromFile(\"../models/solid.json\");","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Write the model to vtk with the command","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"writevtk(model,\"model\");","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"and open the resulting files with Paravaiew in order to inspect it. As you will see, the discretization is done with linear tetrahedral elements. Note also that the boundaries Gamma_rm B and Gamma_rm G are identified in the model with the names \"surface_1\" and \"surface_2\" respectively.  For instance, if you visualize the faces of the model and color them by the field \"surface_2\", you will see that only the faces on Gamma_rm G have a value different from zero.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"(Image: )","category":"page"},{"location":"pages/t003_elasticity/#Vector-valued-FE-space-1","page":"3 Linear elasticity","title":"Vector-valued FE space","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The next step is the construction of the FE space. The main difference with respect to the previous tutorials that discussed the Poisson problem is that we need a vector-valued FE space to solve the current problem. This is achieved as follows","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"const T = VectorValue{3,Float64}\ndiritags = [\"surface_1\",\"surface_2\"]\ndirimasks = [(true,false,false), (true,true,true)]\norder = 1\nV = CLagrangianFESpace(T,model,order,diritags,dirimasks);","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"In the construction of the vector-valued FE space, there are two new concepts deserving some discussion. Note that, in the first argument of the constructor CLagrangianFESpace, we pass the type Vectorvalue{3,Float64}, which is the way Gridap represents vectors of three Float64 components.  Another major difference with respect to previous tutorials is the presence of the argument dirimasks. This argument allows one to chose which components of the displacement are constrained on the Dirichlet boundary and which are not. Note that we constrain only the first component on the boundary Gamma_rm B (i.e., \"surface_1\"), whereas we constrain all components on Gamma_rm G (i.e., \"surface_2\") as it defined in the problem statement.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"At this point, we can define the test and trial spaces. The test space is built as we have detailed in previous tutorials","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"V0 = TestFESpace(V);","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"However, the construction of the trial space is slightly different in this case. The Dirichlet boundary conditions are described with two different functions, one for boundary Gamma_rm B and another one for Gamma_rm G. These functions can be defined as","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"g1(x) = VectorValue(0.005,0.0,0.0)\ng2(x) = zero(T)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Note that it is irrelevant which values we use in the second and third components of the vector returned by function g1 since only the first component is constrained on the boundary Gamma_rm B (i.e., the two last components will be ignored by the code).  Note also that we have used the function zero in function g2 to construct the zero vector of three components.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"From functions g1 and g2, we define the trial space as follows:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"U = TrialFESpace(V,[g1,g2]);","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Notet that the functions g1 and g2 are passed as a vector of functions to the TrialFESpace constructor, one function for each boundary identifier passed previously in the diritags argument of the CLagrangianFESpace constructor.","category":"page"},{"location":"pages/t003_elasticity/#Constitutive-law-1","page":"3 Linear elasticity","title":"Constitutive law","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Once the FE spaces are defined, the next step is to define the weak form.  In this example, the construction of the weak form requires more work than in previous tutorials since we need to account for the constitutive law that relates strain and stress. This becomes evident, when defining (the integrand of) the bilinear form of the problem:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"a(v,u) = inner( ε(v), σ(ε(u)) )","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The symmetric gradient of the test and trial functions are simply computed with the ε function (aka symmetric_gradient) provided by Gridap. However, the function σ that computes the stress tensor has to be defined ad-hoc for this example as we detail now.  The way function σ and other types of constitutive laws are defined  in Gridap is by using the supplied macro @law:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"const E = 70.0e9\nconst ν = 0.33\n\nconst λ = (E*ν)/((1+ν)*(1-2*ν))\nconst μ = E/(2*(1+ν))\n\n@law σ(x,ε) = λ*tr(ε)*one(ε) + 2*μ*ε","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Here are some rules that must be considered, when using this macro. The macro @law is always placed before a function definition.  The arguments of the function annotated with the @law macro represent the values of different quantities at a generic integration point. The first argument always represents the coordinate of the integration point. The remaining arguments have arbitrary meaning. In this example, the second argument represents the strain tensor, from which the stress tensor is to be computed. We have used the function tr (aka trace) and function one in the computation of the stress tensor, whereas we have used material parameters corresponding to aluminum.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The macro @law automatically adds an extra method to the annotated function. The generated method has always an argument less that the original function definition (i.e., the first argument is removed). You can easily check this with following line","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"methods(σ)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"If you run previous in a notebook, we will see that function σ has indeed two methods: the one we have defined, which has 2 arguments, and another with only a single argument that has been created by the macro. The macro-generated method can be used as σ(ε(u)) where u is a trial function in the definition of a bilinear form (as done above), or where u is a FEFunction (as we will use for writing the stress tensor into a vtk file).","category":"page"},{"location":"pages/t003_elasticity/#Solution-of-the-FE-problem-1","page":"3 Linear elasticity","title":"Solution of the FE problem","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The remaining steps for solving the FE problem are essentially the same as in previous tutorials. We build the integration mesh and quadrature for integrating in the volume","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"trian = Triangulation(model)\nquad = CellQuadrature(trian,order=2);","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"We define the FE problem","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"t_Ω = LinearFETerm(a,trian,quad)\nop = LinearFEOperator(V0,U,t_Ω);","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"and we solve it","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"uh = solve(op);","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Note that in the construction of the LinearFEOperator we have used a LinearFETerm instead of an AffineFETerm as it was done in previous tutorial. The LinearFETerm is a particular implementation of FETerm, which only leads to contributions to the system matrix (and not to the right hand side vector). This is what we want in this example since the body forces are zero.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Finally, we write the results to a file","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"writevtk(trian,\"results\",cellfields=[\"uh\"=>uh,\"epsi\"=>ε(uh),\"sigma\"=>σ(ε(uh))])","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Note that we are also including the strain and stress tensors into the results file (indeed, we are using the generated constitutive law for computing the stress tensor associated with the solution). Open the results file and see the computed solution of the problem. It can be clearly observed that the surface  Gamma_rm B is pulled in x_1-direction and that the solid deforms accordingly (in the figure below deformation magnified 40 times).","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"(Image: )","category":"page"},{"location":"pages/t003_elasticity/#Multi-material-problems-1","page":"3 Linear elasticity","title":"Multi-material problems","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"We end this tutorial by extending previous code to deal with multi-material problems. Let us assume that the piece simulated before is now made of 2 different materials (see next figure). In particular, we assume that the volume depicted in dark green is made of aluminum, whereas the volume marked in purple is made of steel.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"(Image: )","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"The two different material volumes are properly identified in the model we have previously loaded. To check this, inspect the model with Paraview (by writing it to vtk format as done before). Note that the volume made of aluminum is identified as \"material_1\", whereas the volume made of steel is identified as \"material_2\".","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"In order to build the constitutive law for the bi-material problem, we need a vector that contains information about the material each cell in the model is composed. This is achieved by these lines","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"labels = FaceLabels(model)\ndimension = 3\ntags = first_tag_on_face(labels,dimension);","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Previous lines generate a vector, namely tags, whose length is the number of cells in the model and for each cell contains an integer that identifies the material of the cell.  This is almost what we need. We also need to know which is the integer value associated with each material. E.g., the integer value associated with \"material_1\" (i.e. aluminum) is retrieved as","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"const alu_tag = tag_from_name(labels,\"material_1\")","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Now, we know that cells whose corresponding value in the tags vector is alu_tag are made of aluminum, otherwise they are made of steel (since there are only two materials in this example).","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"At this point, we are ready to define the multi-material constitutive law. First, we define the material parameters for aluminum and steel respectively:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"function lame_parameters(E,ν)\n  λ = (E*ν)/((1+ν)*(1-2*ν))\n  μ = E/(2*(1+ν))\n  (λ, μ)\nend\n\nconst E_alu = 70.0e9\nconst ν_alu = 0.33\nconst (λ_alu,μ_alu) = lame_parameters(E_alu,ν_alu)\n\nconst E_steel = 200.0e9\nconst ν_steel = 0.33\nconst (λ_steel,μ_steel) = lame_parameters(E_steel,ν_steel)","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Then, we define the function containing the constitutive law:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"@law function σ_bimat(x,ε,tag)\n  if tag == alu_tag\n    return λ_alu*tr(ε)*one(ε) + 2*μ_alu*ε\n  else\n    return λ_steel*tr(ε)*one(ε) + 2*μ_steel*ε\n  end\nend","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Note that in this new version of the constitutive law, we have included a third argument that represents the integer value associated with a certain material. If the value corresponds to the one for aluminum (i.e., tag == alu_tag), then, we use the constitutive law for this material, otherwise, we use the law for steel.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Since we have constructed a new constitutive law, we need to re-define the bilinear form of the problem:","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"a(v,u) = inner( ε(v), σ_bimat(ε(u),tags) )","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"In previous line, pay attention in the usage of the new constitutive law σ_bimat. Note that we have passed the vector tags containing the material identifiers in the last argument of the function`.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"At this point, we can build the FE problem again and solve it","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"t_Ω = LinearFETerm(a,trian,quad)\nop = LinearFEOperator(V0,U,t_Ω)\nuh = solve(op);","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Once the solution is computed, we can store the results in a file for visualization. Note that, we are including the stress tensor in the file (computed with the bi-material law).","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"writevtk(trian,\"results\",cellfields=\n  [\"uh\"=>uh,\"epsi\"=>ε(uh),\"sigma\"=>σ_bimat(ε(uh),tags)])","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Tutorial done!","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/t0041_p_laplacian.jl\"","category":"page"},{"location":"pages/t0041_p_laplacian/#Tutorial-4:-p-Laplacian-1","page":"4 p-Laplacian","title":"Tutorial 4: p-Laplacian","text":"","category":"section"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t0041_p_laplacian/#Learning-outcomes-1","page":"4 p-Laplacian","title":"Learning outcomes","text":"","category":"section"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"How to solve a simple non-linear PDE in Gridap\nHow to define the weak residual and its Jacobian\nHow to setup and use a non-linear solver\nHow to define new boundaries from a given discrete model\nHow to interpolate a function in a FE space","category":"page"},{"location":"pages/t0041_p_laplacian/#Problem-statement-1","page":"4 p-Laplacian","title":"Problem statement","text":"","category":"section"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"The goal of this tutorial is to solve a non-linear PDEs in Gridap. For the sake of simplicity, we consider the p-Laplacian as the model problem. More complex PDEs will be considered in other tutorials. See, e.g., the tutorial on geometrically non-linear elasticity (hyper-elasticity) or the one on the incompressible Navier-Stokes equation. In this tutorial, the PDE we want to solve is","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"leftlbrace\nbeginaligned\n-nabla cdot left( nabla u^p-2 nabla u right) = f textin Omega\nu = 0  texton  Gamma_0\nu = g  texton  Gamma_g\nleft( nabla u^p-2 nabla u right)cdot n = 0  texton  Gamma_rm N\nendaligned\nright","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"This PDE is the p-Laplacian equation of degree p2, equipped with homogeneous Dirichlet and Neumann boundary conditions on Gamma_0 and Gamma_rm N  respectively, and in-homogeneous Dirichlet conditions on Gamma_g.  The domain Omega is the one depicted in the figure below. The Dirichlet boundaries Gamma_0 and Gamma_g are defined as the closure of the green and blue surfaces respectively, whereas the Neumann boundary is the remaining portion of the boundary Gamma_rm NdoteqpartialOmega setminus (Gamma_0cupGamma_g). In this example, we consider the values p=3, f=1, and g=2.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"(Image: )","category":"page"},{"location":"pages/t0041_p_laplacian/#Numerical-scheme-1","page":"4 p-Laplacian","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"As in previous tutorials, we discretize the problem with conforming Lagrangian FE spaces. For this formulation, the weak form reads: find uin U_g such that r(u)(v) = 0 for all vin V_0, where the weak residual r U_g rightarrow (V_0)^prime is defined as","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"r(u)(v) doteq int_Omega nabla v cdot left( nabla u^p-2 nabla u right)  rm dOmega - int_Omega v f  rm dOmega","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"The spaces U_g is the set of functions in H^1(Omega) that fulfill the Dirichlet boundary conditions, whereas V_0 is composed by functions in H^1(Omega) that vanish at the Dirichlet boundary.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"In order to solve this non-linear weak equation, we consider a Newton-Raphson method, which is associated with the following linearization of the problem:  r(u+delta u)(v)approx r(u)(v) + j(u)(vdelta u). The Jacobian evaluated at uin U_g is the bilinear form defined as","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"j(u)(vdelta u) doteq leftdfracrm drm d varepsilonright_varepsilon = 0 r(u+varepsilon  delta u)(v)","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"For the current example, we have","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"j(u)(vdelta u) = int_Omega nabla v cdot left( nabla u^p-2 nabla delta u right)  rm dOmega + (p-2) int_Omega nabla v cdot left(  nabla u^p-4 (nabla u cdot nabla delta u) nabla u  right)  rm dOmega","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Note that the solution of this non-linear PDE with the Newton-Raphson method, will require to discretize both the residual r and the Jacobian j. In Gridap, this is done by following an approach similar to the one already shown in previous tutorials for discretizing the bilinear and linear forms associated with linear FE problems. The specific details are discussed in next section.","category":"page"},{"location":"pages/t0041_p_laplacian/#Implementation-1","page":"4 p-Laplacian","title":"Implementation","text":"","category":"section"},{"location":"pages/t0041_p_laplacian/#Defining-new-boundary-identifiers-1","page":"4 p-Laplacian","title":"Defining new boundary identifiers","text":"","category":"section"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"The first step to solve this PDE in Gridap is to load the discretization of the computational domain. It that case we load the model from a file","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"using Gridap\n\nmodel = DiscreteModelFromFile(\"../models/model.json\");","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Once we have build the discrete model, we have to inspect it in order to see which boundaries are defined in it. To this end, write the model to vtk format and open the resulting file in paraview.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"writevtk(model,\"model\");","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We need to impose Dirichlet boundary conditions on Gamma_0 and Gamma_g as we have stated above, but non of these boundaries is identified in the model. E.g., you can easily see in paraview that the boundary identified as \"sides\" in the model only includes the vertices in the interior of Gamma_0, but, in this example, we want to impose Dirichlet boundary conditions also on the vertices on the contour of Gamma_0 for demonstration purposes. Fortunately, the objects on the contour of Gamma_0 are identified in the model with the tag \"sides_c\" (see figure below). Thus, the Dirichlet boundary Gamma_0 is build as the union of the objects identified as \"sides\" and \"sides_c\".","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"(Image: )","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Gridap provides a convenient way to create new object identifiers (referred as \"tags\") from existing ones. It is done as follows. First, we need to extract from the model, the object that holds the information about the boundary identifiers, which in Gridap is represented with the FaceLabels type:","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"labels = FaceLabels(model);","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Once we have the FaceLabels object (in this case stored in the variable labels), we can add new identifiers (aka \"tags\") to it. In the next line we create a new tag called \"diri0\" as the union of the objects identified as \"sides\" and \"sides_c\", which is precisely what we need to represent the Dirichlet boundary Gamma_0.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"add_tag_from_tags!(labels,\"diri0\",[\"sides\", \"sides_c\"]);","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We follow the same approach to build a new identifier for the Dirichlet boundary Gamma_g. In this case, objects in Gamma_g can be expressed as the union of the objects identified with the tags \"circle\", \"circle_c\", \"triangle\", \"triangle_c\", \"square\", \"square_c\". Thus, we create a new tag for  Gamma_g, called \"dirig\" simply as follows:","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"add_tag_from_tags!(labels,\"dirig\",\n  [\"circle\",\"circle_c\", \"triangle\", \"triangle_c\", \"square\", \"square_c\"])","category":"page"},{"location":"pages/t0041_p_laplacian/#FE-Spaces-1","page":"4 p-Laplacian","title":"FE Spaces","text":"","category":"section"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Now, we can build the FE spaces by using the newly defined boundary tags.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"order = 1\ndiritags = [\"diri0\", \"dirig\"]\nV = CLagrangianFESpace(Float64,model,labels,order,diritags);","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Note that, we pass the labels variable (that contains the newly created boundary tags) in the third argument of the CLagrangianFESpace constructor. From this FE space, we can define the test and trial FE spaces","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"g = 1.0\nV0 = TestFESpace(V)\nUg = TrialFESpace(V,[0.0,g]);","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Note that we set a value of 0.0 on the boundary \"diri0\" and a value of g=1.0 on the boundary \"dirig\" when constructing the trial FE space as it required by the problem statement. Note that in this tutorial we are passing values instead of functions in order describe the prescribed Dirichlet data since the Dirichlet conditions are described with constant functions in this example.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We can perform a final check to see if we have properly imposed the Dirichlet boundary conditions. If we interpolate a constant function, namely w(x) = -1, in the trial FE space U_g, the resulting function w_h has to have value equal to -1 in the nodes that are not on the Dirichlet boundary and fulfill the boundary conditions at the nodes on the Dirichlet boundary. The interpolation is done with the interpolate function as follows","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"w(x) = -1.0\nwh = interpolate(Ug,w)","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"The computed object wh is an instance of FEFunction. We can visualize it as we have already in previous tutorials:","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"trian = Triangulation(model)\nwritevtk(trian,\"wh\",cellfields=[\"wh\"=>wh])","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"If you open the generated file wh.vtu with paraview and chose to color the solid by the field \"wh\" you can confirm that the interpolated function fulfills the Dirichlet boundary conditions as expected (see figure below).","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"(Image: )","category":"page"},{"location":"pages/t0041_p_laplacian/#Non-linear-FE-problem-1","page":"4 p-Laplacian","title":"Non-linear FE problem","text":"","category":"section"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"At this point, we are ready to define the non-linear FE problem. To this end, we need to define the weak residual and also its corresponding Jacobian. The particular way this is done is similar as the strategy seen in previous tutorials to define the term in the weak form in a linear problem. We will also use types inheriting from the abstract type FETerm to define the different terms of the problem.  In this case, instead of an AffineFETerm (which is for linear problems), we use a NonLinearFETerm. An instance of NonLinearFETerm is constructed as follows. First, we need to define the integrand of the weak residual. In this case:","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"using LinearAlgebra: norm\nconst p = 3\n@law flux(x,∇u) = norm(∇u)^(p-2) * ∇u\nf(x) = 1.0\nres(u,v) = inner( ∇(v), flux(∇(u)) ) - inner(v,f)","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Function res is the one representing the integrand of the weak residual r(u)(v). The first argument of function res represents the function uin U_g where the residual is evaluated. The second argument represents a generic test function vin V_0. Note that the notation we have used to define this function is the same as the one we have used in previous tutorials for linear problems. In particular, we have used the macro @law to construct a constitutive relation (in that case the non-linear flux associated with the gradient of the solution).","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"On the other hand, we need to define the (integrand of the) Jacobian associated with this residual, which is done as follows","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"@law dflux(x,∇du,∇u) = (p-2)*norm(∇u)^(p-4)*inner(∇u,∇du)*∇u + norm(∇u)^(p-2) * ∇du\njac(u,v,du) = inner(  ∇(v) , dflux(∇(du),∇(u)) )","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Function jac represents the integrand of the Jacobian j(u)(vdelta u) previously defined. The first argument of function jac stands for function uin U_g where the Jacobian is evaluated. The second argument is a test function vin V_0, and finally the third argument represents an infinitesimal solution increment delta u in V_0. Note that we have also used the macro @law to define the \"linearization\" of the flux.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We can finally build the NonLinearFETerm as follows.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"quad = CellQuadrature(trian,order=2)\nt_Ω = NonLinearFETerm(res,jac,trian,quad)","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Note that we pass in the first and second arguments the functions that represent the intgrands of the residual and Jacobian. The other two arguments, are the triangulation and quadrature used to perform the integrals numerically on the corresponding domain (in this case the volume Omega).","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"From this NonLinearFETerm object, we finally construct the non-linear FE problem as follows.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"op = NonLinearFEOperator(V,Ug,t_Ω)","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"In previous line, we have constructed an instance of NonLinearFEOperator, which is the type that represents a general non-linear FE problem in Gridap. The constructor takes the test and trial spaces of the problem, and the FETerms objects describing the corresponding weak form.","category":"page"},{"location":"pages/t0041_p_laplacian/#Non-linear-solver-phase-1","page":"4 p-Laplacian","title":"Non-linear solver phase","text":"","category":"section"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We have already built the non-linear FE problem. Now, the remaining step is to solve it. In Gridap, non-linear (and also linear) FE problems can be solved with instances of the type NonLinearFESolver. The type NonLinearFESolver is a concrete implementation of the abstract type FESolver particularly designed for non-linear problems (in contrast to the concrete type LinearFESolver which is for the linear case).","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"A NonLinearFESolver is constructed from an algebraic non-linear solver (e.g., a Newton-Raphson solver, a trust-region solver, etc.). In Gridap non-linear algebraic solvers are represented by types inheriting from the abstract type NonLinearSolver. Once of the concrete implementations of this abstract type available in Gridap is the JuliaNLSolver, which uses the nlsove function of the official Julia package NLsolve to solve the underlying non-linear algebraic problem.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"We construct an instance of JuliaNLSolver as follows:","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"using LineSearches: BackTracking\n\nls = BackslashSolver()\nnls = JuliaNLSolver(\n  ls; show_trace=true, method=:newton, linesearch=BackTracking())","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"The first argument of the JuliaNLSolver constructor takes a single positional argument and several keyword arguments. In the positional argument, we pass the linear solver we want to use at each non-linear iteration (if the chosen non-linear solution method requires to solve linear systems of algebraic equations at each iterations). In this case, we use a BackslashSolver which is a wrapper of the Julia built-in \"backslash\" operator. On the other hand, the valid key word arguments are the same as the ones of function nlsolve of the NLsolve package (see the documentation of this package for more information). Note that we are selecting a Newton-Raphson method with a back-traking line-search function. The other keyword arguments are to show and to store a trace of the iterations.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Now, we are finally in place to build the NonLinearFESolver object:","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"solver = NonLinearFESolver(nls)","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"To finally solve the non-linear FE problem, we need to chose an initial guess. The initial guess is a FEFunction, which is in this case is build from a vector for random nodal values:","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"import Random\nRandom.seed!(1234)\n\nx = rand(Float64,num_free_dofs(Ug))\nuh = FEFunction(Ug,x)","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Using, the initial guess and the non-linear FE solver, we solve the problem as follows:","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"solve!(uh,solver,op)","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"If you run previous line in a jupyter notebook, you will see a trace as this one","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Iter     f(x) inf-norm    Step 2-norm\n------   --------------   --------------\n     0     1.139082e+01              NaN\n     1     2.849303e+00     2.361896e+02\n     2     7.176996e-01     6.262418e+01\n     3     1.917792e-01     1.761268e+01\n     4     5.525576e-02     4.295340e+00\n     5     1.186876e-02     6.847898e-01\n     6     2.359521e-03     7.063845e-02\n     7     3.170074e-04     5.936403e-03\n     8     6.754149e-05     5.142141e-04\n     9     1.195143e-05     4.066167e-05\n    10     2.308345e-06     1.832637e-06\n    11     8.679377e-08     2.492892e-08\n    12     1.375616e-10     3.492308e-11","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Note that the solve! function updates the given initial guess with the solution of the problem.  That is, once function solve! returns, the variable uh contains the solution of the problem. To visualize it, execute following line and inspect the generated file with paraview.","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"writevtk(trian,\"results\",cellfields=[\"uh\"=>uh])","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"(Image: )","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"Congratulations, another tutorial done!","category":"page"},{"location":"pages/t0041_p_laplacian/#","page":"4 p-Laplacian","title":"4 p-Laplacian","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Welcome to the tutorial pages of the Gridap.jl project.","category":"page"},{"location":"#How-to-start-1","page":"Introduction","title":"How to start","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The easiest way to start using the tutorials is to click in one of the following links to start reading the html version of the tutorial you want.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Depth = 1","category":"page"},{"location":"#Jupyter-notebooks-1","page":"Introduction","title":"Jupyter notebooks","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"In addition, the tutorials are available as jupyter notebooks. You can access them in three different ways:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"By running the notebooks locally. A working installation of Julia in the system is required. See instructions below. This is the recommended way to follow the tutorials. In particular, it allows to inspect the generated results with Paraview.\nBy running the notebook remotely via binder. In that case, go to the desired tutorial and click the icon (Image: ). No local installation of Julia needed.\nBy reading a non-interactive version of the notebook via nbviewer. In that case, go to the desired tutorial and click the icon (Image: )","category":"page"},{"location":"#How-to-run-the-notebooks-locally-1","page":"Introduction","title":"How to run the notebooks locally","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Clone the repository","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"$ git clone https://github.com/gridap/Tutorials.git","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Move into the folder and open a Julia REPL setting the current folder as the project environment. NOTE: use at least Julia 1.1","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"$ cd Tutorials\n$ julia --project=.\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.1.0 (2019-01-21)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> \n","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Instantiate the environment. This will automatically download all required packages.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"# Type ] to enter in pkg mode\nTutorials> instantiate","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Build the notebooks","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"# Type Ctrl+C to get back to command mode\njulia> include(\"deps/build.jl\")","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Open the notebooks","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> using IJulia\njulia> notebook(dir=pwd())","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This will open a browser window. Navigate to the notebooks folder and open the tutorial you want. Enjoy!","category":"page"},{"location":"#How-to-pull-the-latest-version-of-the-tutorials-1","page":"Introduction","title":"How to pull the latest version of the tutorials","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you have cloned the repository a while ago, you can update to the newest version with these steps.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Go to the Tutorials repo folder and git pull","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"$ git pull","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Open Julia REPL","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"$ julia --project=.\n","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"and instantiate the environment and build the notebooks again","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"# Type ] to enter in pkg mode\nTutorials> instantiate\n\n# Type Ctrl+C to get back to command mode\njulia> include(\"deps/build.jl\")","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Done!","category":"page"}]
}
