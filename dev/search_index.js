var documenterSearchIndex = {"docs":
[{"location":"pages/t004_hyperelasticity/#","page":"4 Hyper-elasticity","title":"4 Hyper-elasticity","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/t004_hyperelasticity.jl\"","category":"page"},{"location":"pages/t004_hyperelasticity/#Tutorial-4:-Hyperelasticity-1","page":"4 Hyper-elasticity","title":"Tutorial 4: Hyperelasticity","text":"","category":"section"},{"location":"pages/t004_hyperelasticity/#","page":"4 Hyper-elasticity","title":"4 Hyper-elasticity","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t004_hyperelasticity/#Problem-statement-1","page":"4 Hyper-elasticity","title":"Problem statement","text":"","category":"section"},{"location":"pages/t004_hyperelasticity/#","page":"4 Hyper-elasticity","title":"4 Hyper-elasticity","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"4 Hyper-elasticity","title":"4 Hyper-elasticity","text":"using Gridap","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"4 Hyper-elasticity","title":"4 Hyper-elasticity","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.","category":"page"},{"location":"pages/t004_hyperelasticity/#","page":"4 Hyper-elasticity","title":"4 Hyper-elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/t002_validation.jl\"","category":"page"},{"location":"pages/t002_validation/#Tutorial-2:-Code-validation-1","page":"2 Code validation","title":"Tutorial 2: Code validation","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t002_validation/#Learning-outcomes-1","page":"2 Code validation","title":"Learning outcomes","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"How to use the method of manufactured solutions\nHow to perform a convergence test\nHow to define the discretization error\nHow to integrate error norms\nHow to generate Cartesian meshes in arbitrary dimensions","category":"page"},{"location":"pages/t002_validation/#Problem-statement-1","page":"2 Code validation","title":"Problem statement","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In this tutorial, we show how to validate a code using the well known method of manufactured solutions. For the sake of simplicity, we consider the Poisson equation in the unit square Omegadoteq (01)^2 as a model problem,","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton partialOmega\nendaligned\nright","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We are going to consider two different manufactured solutions u. On the one hand, we consider function u(x)=x_1+x_2, which is exactly represented by the FE interpolation to be constructed below. In that case, one expects that the obtained approximation error is near the machine precision. We are going to check that it is the case in the code. On the other hand, we will consider a function that cannot be captured exactly by the interpolation, namely u(x)=x_2 sin(2 pi x_1). In this case, we will check that the order of convergence of the discretization error is the optimal one.","category":"page"},{"location":"pages/t002_validation/#Manufactured-solution-1","page":"2 Code validation","title":"Manufactured solution","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We start by defining the manufactured solution u(x) = x_1+x_2 and the source term f associated with it, that is fdoteq-Delta(x_1+x_2)=0.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"using Gridap\n\nu(x) = x[1] + x[2]\nf(x) = 0.0","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Note that it is important that function f returns a Float64 value. This is needed since we are going to use Float64 numbers to represent the solution.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We also need to define the gradient of u since we will compute the H^1 error norm later. In that case, the gradient is simply defined as","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"∇u(x) = VectorValue(1.0,1.0)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Note that we have used the constructor VectorValue to build the vector that represents the gradient. We still need a final trick. We need to tell the Gridap library that the gradient of the function u is available in the function ∇u (at this moment u and ∇u are two standard Julia functions without any connection between them). This is done by adding an extra method to the function gradient (aka ∇) defined in Gridap, namely","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"import Gridap: ∇\n∇(::typeof(u)) = ∇u","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Now, it is possible to recover function ∇u from function u as ∇(u). You can check that the following expression evaluates to true.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"∇(u) === ∇u","category":"page"},{"location":"pages/t002_validation/#Cartesian-mesh-generation-1","page":"2 Code validation","title":"Cartesian mesh generation","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In order to discretized the geometry of the unit square, we use the Cartesian mesh generator available in Gridap:","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"limits = (0.0,1.0,0.0,1.0)\nmodel = CartesianDiscreteModel(domain=limits, partition=(4,4));","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The type CartesianDiscreteModel is a concrete type that inherits from DiscreteModel, which is specifically designed for building Cartesian meshes. It is constructed from a tuple containing limits of the domain we want to discretize  plus a tuple with the number of elements to be generated in each direction, in this case 4 by 4 elements. Note that the CaresianDiscreteModel is implemented for arbitrary dimensions. For instance, the following lines build a CartesianDiscreteModel  for the unit cube (01)^3 with 4 elements per direction","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"limits3d = (0.0,1.0,0.0,1.0,0.0,1.0)\nmodel3d = CartesianDiscreteModel(domain=limits3d, partition=(4,4,4));","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"You could also generate a mesh for the unit tesseract (01)^4 (i.e., the unit cube in 4D). Look how the 2D and 3D models are build and just follow the sequence.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Let us return to the 2D CartesianDiscreteModel we have constructed. You can inspect it by writing it into vtk format. Note that you can also print the 3D model, but not the 4D ones. In the future, it would be cool to generate a movie from a 4D model, but this functionality is not yet implemented.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"writevtk(model,\"model\");","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"If you open the generated files, you will see that the boundary vertices and facets are identified with the name \"boundary\". This is just what we need to impose the Dirichlet boundary conditions in this example.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"(Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"(Image: )","category":"page"},{"location":"pages/t002_validation/#FE-approximation-1","page":"2 Code validation","title":"FE approximation","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We compute a FE approximation of this example by following the steps detailed in previous tutorial.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"order = 1\ndiritag = \"boundary\"\nV = CLagrangianFESpace(Float64,model,order,diritag)\n\nV0 = TestFESpace(V)\nU = TrialFESpace(V,u)\n\ntrian = Triangulation(model)\nquad = CellQuadrature(trian,order=2)\n\na(v,u) = inner(∇(v), ∇(u))\nb(v) = inner(v,f)\n\nt_Ω = AffineFETerm(a,b,trian,quad)\nop = LinearFEOperator(V0,U,t_Ω)\n\nuh = solve(op)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Note that we are imposing Dirichlet boundary conditions on the objects tagged as \"boundary\" and that we are using the manufactured solution u to construct the trial FE space. Not also that we are not explicitly constructing an Assembler object nor a FESolver. We are relying on default values.","category":"page"},{"location":"pages/t002_validation/#Measuring-the-discretization-error-1","page":"2 Code validation","title":"Measuring the discretization error","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Our goal is to check that the discratization error associated with the computed approximation uh is near machine precision. To this end, the first step is to compute the discretization error, which is done as you would expect:","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"e = u - uh","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Once the error is defined, you can, e.g., visualize it.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"writevtk(trian,\"error\",cellfields=[\"e\" => e]);","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"This generates a file called error.vtu. Open it with Paraview to check that the error is of the order of the machine precision.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"(Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"A more rigorous way of quantifying the error is to measure it with a norm. Here we use the L^2 and H^1 norms, which are defined as","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":" w _L^2^2 doteq int_Omega w^2  textdOmega quad\n w _H^1^2 doteq int_Omega w^2 + nabla w cdot nabla w  textdOmega\n","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In order to compute these norms, we are going to use the integrate function. First, we need to define the integrands of the integrals we want to evaluate, namely","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"l2(w) = inner(w,w)\nh1(w) = a(w,w) + l2(w)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Note that we have reused the integrand of the bilinear form a(cdotcdot) to define the integrand of the H^1 norm. Once we have defined the integrands, we proceed to compute the integrals. For the L^2 norm","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"el2 = sqrt(sum( integrate(l2(e),trian,quad) ))","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"and for the H^1 norm","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"eh1 = sqrt(sum( integrate(h1(e),trian,quad) ))","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The integrate function works as follows. In the first argument we pass the integrand. In the second argument, we pass a Triangulation object representing the integration domain and, in the third argument, we pass a quadrature in order to perform the integrals numerically. The integrate function returns an object containing the contribution to the integral of each one of the cells in the given Triangulation. To end up we the desired error norms, one has to sum these contributions and take the square root. You can check that the computed error norms are really small (as one would expect).","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"tol = 1.e-10\n@assert el2 < tol\n@assert eh1 < tol","category":"page"},{"location":"pages/t002_validation/#Convergence-test-1","page":"2 Code validation","title":"Convergence test","text":"","category":"section"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We end up this tutorial by performing a convergence test making use of all the new concepts we have leaned.  We will consider a manufactured solution that does not belong to the FE interpolation as we have anticipated at the beginning of the tutorial. In this experiment, we expect to see the optimal convergence order of the FE interpolation.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"const k = 2*pi\nu(x) = sin(k*x[1]) * x[2]\n∇u(x) = VectorValue(k*cos(k*x[1])*x[2], sin(k*x[1]))\nf(x) = (k^2)*sin(k*x[1])*x[2]","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Since we have redefined the valiables u, ∇u, and f, we need to execute these lines again","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"∇(::typeof(u)) = ∇u\nb(v) = inner(v,f)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"In order to perform the convergence test, we collect in a function all the code needed to perform a single computation and measure its error. The input of this function is the number of mesh elements in each direction and the interpolation order. The output is the computed L^2 and H^1 error norms.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"function run(n,order)\n\n  limits = (0.0,1.0,0.0,1.0)\n  model = CartesianDiscreteModel(domain=limits, partition=(n,n))\n\n  diritag = \"boundary\"\n  V = CLagrangianFESpace(Float64,model,order,diritag)\n\n  V0 = TestFESpace(V)\n  U = TrialFESpace(V,u)\n\n  trian = Triangulation(model)\n  quad = CellQuadrature(trian,order=order+2)\n\n  t_Ω = AffineFETerm(a,b,trian,quad)\n  op = LinearFEOperator(V0,U,t_Ω)\n\n  uh = solve(op)\n\n  e = u - uh\n\n  el2 = sqrt(sum( integrate(l2(e),trian,quad) ))\n  eh1 = sqrt(sum( integrate(h1(e),trian,quad) ))\n\n  (el2, eh1)\n\nend","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The following function does the convergence test. It takes a vector of integers (representing the number of elements per direction in each computation) plus the interpolation order. It returns the L^2 and H^1 error norms for each computation as well as the considered element size.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"function conv_test(ns,order)\n\n  el2s = Float64[]\n  eh1s = Float64[]\n  hs = Float64[]\n\n  for n in ns\n\n    el2, eh1 = run(n,order)\n    h = 1.0/n\n\n    push!(el2s,el2)\n    push!(eh1s,eh1)\n    push!(hs,h)\n\n  end\n\n  (el2s, eh1s, hs)\n\nend","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"We are ready to perform the test! We consider several mesh sizes and interpolation order equal to 2.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"el2s, eh1s, hs = conv_test([8,16,32,64,128],2);","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"With the generated data, we do the classical convergence plot.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"using Plots\n\nplot(hs,[el2s eh1s],\n    xaxis=:log, yaxis=:log,\n    label=[\"L2\" \"H1\"],\n    shape=:auto,\n    xlabel=\"h\",ylabel=\"error norm\")","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"If you run the code in a notebook, you will see a figure like this one: (Image: )","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The generated curves make sense. It is observed that the convergence of the H^1 error is slower that L^2 one. However, in order to be more conclusive, we need to compute the slope of these lines. It can be done with this little function that internally uses a linear regression.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"function slope(hs,errors)\n  x = log10.(hs)\n  y = log10.(errors)\n  linreg = hcat(fill!(similar(x), 1), x) \\ y\n  linreg[2]\nend","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"The slope for the L^2 error norm is computed as","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"slope(hs,el2s)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"and for the H^1 error norm","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"slope(hs,eh1s)","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"If your run these lines in a notebook, you will see that the slopes for the L^2 and H^1 error norms are about 3 and 2 respectively, as one expects for interpolation order 2.","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"Congrats, another tutorial done!","category":"page"},{"location":"pages/t002_validation/#","page":"2 Code validation","title":"2 Code validation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/t001_poisson.jl\"","category":"page"},{"location":"pages/t001_poisson/#Tutorial-1:-Poisson-equation-1","page":"1 Poisson equation","title":"Tutorial 1: Poisson equation","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t001_poisson/#Learning-outcomes-1","page":"1 Poisson equation","title":"Learning outcomes","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"How to solve a simple PDE in Julia with Gridap\nHow to load a discrete model (aka a FE mesh) from a file\nHow to build Conforming Lagrangian FE spaces\nHow to define the different terms in a weak form\nHow to impose Dirichlet and Neumann boundary conditions\nHow to visualize results","category":"page"},{"location":"pages/t001_poisson/#Problem-statement-1","page":"1 Poisson equation","title":"Problem statement","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"We want to solve the Poisson equation on the 3D domain depicted in the figure below with Dirichlet and Neumann boundary conditions. Dirichlet boundary conditions are applied on Gamma_rm D, being the outer sides of the prism (marked in red). Non-homogeneous Neumann conditions are applied to the internal boundaries Gamma_rm G, Gamma_rm Y, and Gamma_rm B (marked in green, yellow and blue respectively). And homogeneous Neumann boundary conditions are applied in Gamma_rm W, the remaining portion of the boundary (marked in white).","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: model)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Formally, the problem to solve is: find u such that","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"leftlbrace\nbeginaligned\n-Delta u = f   textin  Omega\nu = g  texton Gamma_rm D\nnabla ucdot n = h  texton  Gamma_rm N\nendaligned\nright","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"being n the outwards unit normal vector to the Neumann boundary Gamma_rm N doteq Gamma_rm GcupGamma_rm YcupGamma_rm BcupGamma_rm W. For simplicity, we chose f(x) = 1, g(x) = 2, and h(x)=3 on Gamma_rm GcupGamma_rm YcupGamma_rm B and h(x)=0 on Gamma_rm W. The variable x is the position vector x=(x_1x_2x_3).","category":"page"},{"location":"pages/t001_poisson/#Numerical-scheme-1","page":"1 Poisson equation","title":"Numerical scheme","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In this first tutorial, we use a conventional Galerkin finite element (FE) method with conforming Lagrangian finite element spaces. The model problem reduces to the weak equation: find uin U_g such that $ a(v,u) = b(v) $ for all vin V_0, where U_g and V_0 are the subset of functions in H^1(Omega) that fulfill the Dirichlet boundary condition g and 0 respectively. The bilinear and linear forms for this problems are","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"a(vu) doteq int_Omega nabla v cdot nabla u  rm dOmega quad b(v) doteq int_Omega v f   rm  dOmega + int_Gamma_rm N v g  rm dGamma_rm N","category":"page"},{"location":"pages/t001_poisson/#Implementation-1","page":"1 Poisson equation","title":"Implementation","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In order to solve this problem in Gridap,  we are going to build the main objects that are involved in the weak formulation.  The step number 0, is to load the Gridap project. If you have configured your environment properly, it is simply done like this:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"using Gridap","category":"page"},{"location":"pages/t001_poisson/#Discrete-model-1","page":"1 Poisson equation","title":"Discrete model","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"As in any FE simulation, we need a discretization of the computational domain (i.e a FE mesh), which contains information of the different boundaries to impose boundary conditions. All geometrical data needed for solving a FE problem is provided in Gridap by types inheriting from the abstract type DiscreteModel. In the following line, we build an instance of DiscreteModel by loading a model from a json file.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"model = DiscreteModelFromFile(\"../models/model.json\");","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"You can easily inspect the generated model in Paraview by writting it to vtk format.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"writevtk(model,\"model\");","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Previous line generates four different files model_0.vtu, model_1.vtu, model_2.vtu, and model_3.vtu containing the vertices, edges, faces, and cells present in the discrete model. Moreover, you can easily inspect, which boundaries are defined within the model.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"For instance, if we want to see which faces of the model are on the boundary Gamma_rm B (i.e., the walls of the circular hole), open the file model_2.vtu and chose coloring by the element field \"circle\". You should see that only the faces on the circular hole have a value different from 0.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: )","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"It is also possible to see which vertices are on the Dirichlet boundary Gamma_rm D. To do so, open the file model_0.vtu and chose coloring by the field \"sides\".","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: )","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"That is, the boundary Gamma_rm B (i.e., the walls of the circular hole) is called \"circle\" and the Dirichlet boundary Gamma_rm D is called \"sides\" in the model. In addition, the walls of the triangular hole Gamma_rm G and the walls of the square hole Gamma_rm Y are identified in the model with the names \"triangle\" and \"square\" respectively.","category":"page"},{"location":"pages/t001_poisson/#FE-spaces-1","page":"1 Poisson equation","title":"FE spaces","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Once we have a discretization of the computational domain, the next step is to generate a discrete approximation of the finite element spaces V_0 and U_g (i.e. the test and trial FE spaces) of the problem. To do so, first, we are going to build a discretization of H^1(Omega), namely V, defined as the standard Conforming Lagrangian FE space (without boundary conditions) associated with the discretization of the computational domain. Note that functions in V are free on the Dirichlet boundary (which is not the case for V_0 and U_g). The FE space V is build as follows:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"order = 1\ndiritag = \"sides\"\nV = CLagrangianFESpace(Float64,model,order,diritag);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In the first argument, we pass the data type that represents the value of the functions in the space. In that case, Float64 since the unknown of our problem is scalar-valued and it will be represented with a 64-bit floating point number. In addition, we pass the model on top of which we want to construct the space, the interpolation order, and the name of the entities that are on the Dirichlet boundary. Note that, even though functions in V are not constrained by Dirichlet boundary conditions, the underlaying implementation is aware of which functions have support on the Dirichlet boundary. This is why we need to pass the argument diritag.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The approximations for the test and trial spaces V_0 and U_g are build simply as","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"g(x) = 2.0\nV0 = TestFESpace(V)\nUg = TrialFESpace(V,g);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Note that functions in the test space are always constrained to 0 on the Dirichlet boundary, whereas functions on the trial space are constrained to the given boundary function. In this case, function g.","category":"page"},{"location":"pages/t001_poisson/#Numerical-integration-1","page":"1 Poisson equation","title":"Numerical integration","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Once we have build the interpolation spaces, the next step is to set up the machinery to perform the integrals in the weak form numerically. Here, we need to compute integrals on the interior of the domain Omega and on the Neumann boundary Gamma_rm N. In both cases, we need two main ingredients. We need to define an integration mesh (i.e. a set of cells that form a partition of the integration domain), plus a Gauss-like quadrature in each of the cells. In Gridap, integration meshes are represented by types inheriting from the abstract type Triangulation. For integrating on the domain Omega, we build the following integration mesh and quadrature:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"trian = Triangulation(model)\nquad = CellQuadrature(trian,order=2);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Note that in this simple case, we are using the cells of the model as integration cells, but in more complex formulations (e.g., embedded finite element computations) the integration cells can be different from the cells on the background FE mesh. Note also, that we are constructing a quadrature of order 2 in the cells of the integration mesh. This is enough for integrating all terms of the weak form exactly for an interpolation of order 1.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"On the other hand, we need a special type of integration mesh, represented by the type BoundaryTriangulation, to integrate on the boundary. We build an instance of this type from the discrete model and the names used to identify on the Neumann boundary as follows:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"neumanntags = [\"circle\", \"triangle\", \"square\"]\nbtrian = BoundaryTriangulation(model,neumanntags)\nbquad = CellQuadrature(btrian,order=2);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Note that we have also created a quadrature of order 2 on top of the integration mesh for the Neumann boundary.","category":"page"},{"location":"pages/t001_poisson/#Weak-form-1","page":"1 Poisson equation","title":"Weak form","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"With all the ingredients presented so far, we are ready to set up define our FE problem.  First, we need to define the weak form of the problem at hand. This is done by means of types inheriting from the abstract type FETerm. In this tutorial, we will use the sub types AffineFETerm and FESource. An AffineFETerm is a term that contributes both to the system matrix and the right-hand-side vector, whereas a FESource only contributes to the right hand side vector.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In this example, we use an AffineFETerm to represent all the terms in the weak form that are integrated over the interior of the domain Omega. It is constructed like this:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"f(x) = 1.0\na(v,u) = inner( ∇(v), ∇(u) )\nb_Ω(v) = inner(v, f)\nt_Ω = AffineFETerm(a,b_Ω,trian,quad);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"In the first argument, we pass a function that represents the integrand of the bilinear form a(cdotcdot), the second argument is a function that represents the integrand of part of the billinar form b(cdot) that is integrated over the domain Omega. The third argument is the Triangulation on which we want to perform the integration (in that case the integration mesh for Omega), and the last argument is the CellQuadrature needed to perform the integration numerically.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Note that the contribution associated with the Neumann condition is integrated over a different domain, and thus, cannot be included in the previous AffineFETerm. To account for it, we use a FESource object:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"h(x) = 3.0\nb_Γ(v) = inner(v, h)\nt_Γ = FESource(b_Γ,btrian,bquad);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Here, we pass in the first argument the integrand of the Neumann boundary condition, and in the lasts arguments we pass the integration mesh and quadrature for the Neumann boundary.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Presenting the precise notation used to define the integrands of the weak form is out of the scope of this first tutorial. But for the moment, the following remarks are enough. Variables v and u  represents a test and trial function respectively. The function ∇ represents the gradient operator. The function inner represents the inner product. It is extremely important to be aware that the implementation of the inner function is not commutative! The first argument is always for the test function (which will be associated with the rows of the system matrix or the right hand side vector depending on the case). Not following this rule can end up with matrices that are the transpose of the matrix you really want or with code crashes in the worst case. Note that we have always correctly placed the test function v in the first argument.","category":"page"},{"location":"pages/t001_poisson/#FE-problem-1","page":"1 Poisson equation","title":"FE problem","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"At this point, we can combine all ingredients and formulate our FE problem. A FE problem (both for linear and non-linear cases) is represented in the code by types inheriting from the abstract type FEOperator. Since we want to solve a linear problem, we use the concrete type LinearFEOperator:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"assem = SparseMatrixAssembler(V0,Ug)\nop = LinearFEOperator(V0,Ug,assem,t_Ω,t_Γ);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Note that we build the LinearFEOperator object from the test and trial FE spaces and the FE terms constructed before. We also need to provide an Assembler object, which represents the strategy to assemble the system. In this case, we use a SparseMatrixAssembler, which will use Julia build-in sparse matrices.","category":"page"},{"location":"pages/t001_poisson/#Solver-phase-1","page":"1 Poisson equation","title":"Solver phase","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"We have constructed a FE problem, the last step is to solve it. In Gridap, FE problems are solved with types inheriting from the abstract type FESolver. Since this is a linear problem, we use a LinearFESolver:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"ls = LUSolver()\nsolver = LinearFESolver(ls)","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"LinearFESolver objects are build from a given algebraic linear solver. In this case, we use a LU factorization. Now we are ready to solve the problem as follows:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"uh = solve(solver,op);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"The solution of the problem uh is an instance of FEFunction, the type used to represent a function in a FE space. We can inspect the result by writing it into a vtk file:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"writevtk(trian,\"results\",cellfields=[\"uh\"=>uh]);","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"which will generate a file named results.vtu having a nodal field named uh containing the solution of our problem. If you open it, you will see something like this:","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"(Image: )","category":"page"},{"location":"pages/t001_poisson/#Summary-1","page":"1 Poisson equation","title":"Summary","text":"","category":"section"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Since this has been a quite long tutorial, we end up by wrapping all the code we have used.","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"using Gridap\n\n#Read the discrete model\nmodel = DiscreteModelFromFile(\"../models/model.json\")\n\n#Setup FE space\norder = 1\ndiritag = \"sides\"\nV = CLagrangianFESpace(Float64,model,order,diritag)\n\n#Setup test and trial spaces\ng(x) = 2.0\nV0 = TestFESpace(V)\nUg = TrialFESpace(V,g)\n\n#Setup numerical integration (volume)\ntrian = Triangulation(model)\nquad = CellQuadrature(trian,order=2)\n\n#Setup numerical integration (boundary)\nneumanntags = [\"circle\", \"triangle\", \"square\"]\nbtrian = BoundaryTriangulation(model,neumanntags)\nbquad = CellQuadrature(btrian,order=2)\n\n#Setup FE terms (volume)\nf(x) = 1.0\na(v,u) = inner( ∇(v), ∇(u) )\nb_Ω(v) = inner(v, f)\nt_Ω = AffineFETerm(a,b_Ω,trian,quad)\n\n#Setup FE terms (boundary)\nh(x) = 3.0\nb_Γ(v) = inner(v, h)\nt_Γ = FESource(b_Γ,btrian,bquad)\n\n#Setup FE problem\nassem = SparseMatrixAssembler(V0,Ug)\nop = LinearFEOperator(V0,Ug,assem,t_Ω,t_Γ)\n\n#Solve it!\nls = LUSolver()\nsolver = LinearFESolver(ls)\nuh = solve(solver,op)\n\n#Write results\nwritevtk(trian,\"results\",cellfields=[\"uh\"=>uh])","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"Congrats, tutorial done!","category":"page"},{"location":"pages/t001_poisson/#","page":"1 Poisson equation","title":"1 Poisson equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"EditURL = \"https://github.com/gridap/Tutorials/blob/master/src/t003_elasticity.jl\"","category":"page"},{"location":"pages/t003_elasticity/#Tutorial-3:-Linear-elasticity-1","page":"3 Linear elasticity","title":"Tutorial 3: Linear elasticity","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"(Image: ) (Image: )","category":"page"},{"location":"pages/t003_elasticity/#Problem-statement-1","page":"3 Linear elasticity","title":"Problem statement","text":"","category":"section"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"using Gridap","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.","category":"page"},{"location":"pages/t003_elasticity/#","page":"3 Linear elasticity","title":"3 Linear elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Welcome to the tutorial pages of the Gridap.jl project.","category":"page"},{"location":"#How-to-start-1","page":"Introduction","title":"How to start","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The easiest way to start using the tutorials is to click in one of the following links to start reading the html version of the tutorial you want.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Depth = 1","category":"page"},{"location":"#Jupyter-notebooks-1","page":"Introduction","title":"Jupyter notebooks","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"In addition, the tutorials are available as jupyter notebooks. You can access them in three different ways:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"By running the notebooks locally. A working installation of Julia in the system is required. See instructions below. This is the recommended way to follow the tutorials. In particular, it allows to inspect the generated results with Paraview.\nBy running the notebook remotely via binder. In that case, go to the desired tutorial and click the icon (Image: ). No local installation of Julia needed.\nBy reading a non-interactive version of the notebook via nbviewer. In that case, go to the desired tutorial and click the icon (Image: )","category":"page"},{"location":"#How-to-run-the-notebooks-locally-1","page":"Introduction","title":"How to run the notebooks locally","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Clone the repository","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"$ git clone https://github.com/gridap/Tutorials.git","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Move into the folder and open a Julia REPL setting the current folder as the project environment. NOTE: use at least Julia 1.1","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"$ cd Tutorials\n$ julia --project=.\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.1.0 (2019-01-21)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> \n","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Instantiate the environment. This will automatically download all required packages.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"# Type ] to enter in pkg mode\nTutorials> instantiate","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Build the notebooks","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Tutorials> build","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Open the notebooks","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"# Type Ctrl+C to get back to command mode\njulia> using IJulia\njulia> notebook(dir=pwd())","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This will open a browser window. Navigate to the notebooks folder and open the tutorial you want. Enjoy!","category":"page"},{"location":"#How-to-pull-the-latest-version-of-the-tutorials-1","page":"Introduction","title":"How to pull the latest version of the tutorials","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you have cloned the repository a while ago, you can update to the newest version with these steps.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Go to the Tutorials repo folder and git pull","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"$ git pull","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Open Julia REPL","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"$ julia --project=.\n","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"and instantiate and build the environment again","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"# Type ] to enter in pkg mode\nTutorials> instantiate\nTutorials> build","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Done!","category":"page"}]
}
